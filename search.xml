<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>安装Anaconda与PyTorch库(GPU版本)</title>
      <link href="/article/fcd2699.html"/>
      <url>/article/fcd2699.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装-Anaconda"><a href="#一、安装-Anaconda" class="headerlink" title="一、安装 Anaconda"></a>一、安装 Anaconda</h1><p>经实践，低版本的 Anaconda 仍然可以安装较新版本的三方库，因此已安装过的老司机不必卸载重装 Anaconda，哪怕你的计算机内还安装有十几款不同版本的Python 解释器，只要你的 Anaconda 还能创建虚拟环境，就可跳过本章。</p><h2 id="1-1-去镜像源下载-Anaconda"><a href="#1-1-去镜像源下载-Anaconda" class="headerlink" title="1.1  去镜像源下载 Anaconda"></a>1.1  去镜像源下载 Anaconda</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image002.jpg" alt="img"></td></tr></tbody></table><p>进入网址：<a href="https://mirrors.bfsu.edu.cn/anaconda/archive/">https://mirrors.bfsu.edu.cn/anaconda/archive/</a> ，下载最新版本，视频中为 2022.10-Win 版本，其内部主环境（base 环境）下的 Python 为 3.9 版本。</p><p>图 1-1 下载 Anaconda 安装包</p><p>考虑到后面会用虚拟环境，创建虚拟环境时可以设置新环境中的 Python 解释器版本，所以这里下载哪一版 Anaconda 并不重要。</p><h2 id="1-2-安装-Anaconda"><a href="#1-2-安装-Anaconda" class="headerlink" title="1.2  安装 Anaconda"></a>1.2  安装 Anaconda</h2><p>双击刚刚下载的exe 文件，会有三个分岔口，分别按下列规则选择。</p><p>① Just me 和 All Users，选择 Just me；</p><p>② 安装路径选择最大的盘（一般是 D 盘），放在新建的【D:\Anaconda】里；</p><p>③ 最后一个分岔口，不勾选第一个方框，按照如图 1-2 所示选择。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image004.jpg" alt="img"></td></tr></tbody></table><p>图 1-2 最后一个分岔口</p><p>安装过程可能很漫长，进度条会停在约 90%的位置共 20 分钟，请耐心等待。安装完毕后，我们于第二章手动添加环境变量。</p><h1 id="二、配置-Anaconda-的环境变量"><a href="#二、配置-Anaconda-的环境变量" class="headerlink" title="二、配置 Anaconda 的环境变量"></a>二、配置 Anaconda 的环境变量</h1><p>请跳过第一章的老司机检查自己的环境变量是否安装正确。环境变量的打开方法：</p><p>① 桌面按下鼠标反键，点击“显示设置”，如图 2-1 所示。</p><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image006.jpg" alt="img"></th><th><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image008.jpg" alt="img"></th><th><img src="C:/Users/35940/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img"></th></tr></thead><tbody><tr><td>（a）Win10</td><td>（b）Win11</td><td>（c）显示设置</td></tr></tbody></table><p>图 2-1 显示设置</p><p>② 在左上角“查找设置”中输入“环境变量”，点击“编辑系统环境变量”。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image012.jpg" alt="img"></td></tr></tbody></table><p>图 2-2 点击“编辑系统环境变量”</p><p>③ 在弹出的“系统属性”窗口中点击“环境变量”，再在弹出的“环境变量”窗口中选中path 路径，并点击编辑。</p><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image014.jpg" alt="img"></th><th><img src="C:/Users/35940/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg" alt="img"></th></tr></thead><tbody><tr><td>（a）“系统属性”窗口</td><td>（b）“环境变量”窗口</td></tr></tbody></table><p>图 2-3 打开“编辑系统环境变量”</p><p>④ 通过右侧的“新建”按钮，可新建环境变量的路径，将【D:\Anaconda】、</p><p>【D:\Anaconda\Scripts】与【D:\Anaconda\Library\bin】添加到环境变量。</p><p>请注意，根据此视频旧版的读者反馈，若此前用户为其它多余的 Python 解释器添加过环境变量，请删除之，否则 Anaconda 的环境变量会被挤掉。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image018.jpg" alt="img"></p><p>图 2-4 添加环境变量</p><p>此外，最后请注意，若某人的 Anaconda 安装路径不是 D:\Anaconda，而是 E:\Anaconda，以上三个环境变量请改为【E:\Anaconda】、【E:\Anaconda\Scripts】与【E:\Anaconda\Library\bin】。</p><h1 id="三、设置-Jupyter-Notebook"><a href="#三、设置-Jupyter-Notebook" class="headerlink" title="三、设置 Jupyter Notebook"></a>三、设置 Jupyter Notebook</h1><h2 id="3-1-添加快捷方式"><a href="#3-1-添加快捷方式" class="headerlink" title="3.1  添加快捷方式"></a>3.1  添加快捷方式</h2><p>先找到Jupyter 的安装路径，win10 和 win11 的方法如图 3-1 所示。</p><table><thead><tr><th><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image020.jpg" alt="img"></th><th><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image022.jpg" alt="img"></th></tr></thead><tbody><tr><td>（a）win10</td><td>（b）win11</td></tr></tbody></table><p>图 3-1 找到Jupyter 的位置</p><p>找到Jupyter 的位置后，把Jupyter 和Prompt 复制到桌面，如图 3-2 所示。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image024.jpg" alt="img"></td></tr></tbody></table><p>图 3-2 直接把快捷方式复制到桌面</p><h2 id="3-2-用户名为中文的解决办法"><a href="#3-2-用户名为中文的解决办法" class="headerlink" title="3.2  用户名为中文的解决办法"></a>3.2  用户名为中文的解决办法</h2><p>计算机用户名（即 C:\Users\用户名）为中文，无法兼容 Jupyter。大家可以打开Prompt 检查自己的用户名，如图 3-3。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image026.jpg" alt="img"></p><p>图 3-3 查看自己的用户名</p><p>如果发现自己的用户名携带有中文，在Prompt 里输入以下两端代码：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image027.gif" alt="文本框: pip uninstall pyzmq pip install pyzmq==19.0.2 "></td></tr></tbody></table><p>输入后，再双击Jupyter，应该就可以了。若还解决不了，就重装系统盘（C盘），重装后用户名自动变英文，但这个风险很大，小白不要轻易尝逝。不行的话，听完本次课程后，下载PyCharm 代码编辑器，创建项目时导入 Anaconda 环境，即可替代Jupyter。</p><h2 id="3-3-修改-Jupyter-的工作路径"><a href="#3-3-修改-Jupyter-的工作路径" class="headerlink" title="3.3  修改 Jupyter 的工作路径"></a>3.3  修改 Jupyter 的工作路径</h2><p>Jupyter 初始的工作路径为【C:\Users\用户名】，需要进行修正，将其转移到新建的【D:\Jupyter】位置。</p><p>① 新建 D:\Jupyter；</p><p>② 打开桌面快捷方式中的Prompt；</p><p>③ 输入jupyter notebook –generate-config 命令并执行；</p><p>④ 打开上一步生成的配置文件地址，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\.jupyter</span><br></pre></td></tr></table></figure><p>⑤ 在jupyter_notebook_config.py（以记事本方式打开）中使用Ctrl + F 查找并且修改如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改前：# c.NotebookApp.notebook_dir = &#x27;&#x27;</span><br><span class="line">修改后： c.NotebookApp.notebook_dir = &#x27;D:\Jupyter&#x27;</span><br></pre></td></tr></table></figure><p>也即删除前面的#号注释，在后面的单引号里输入要设置的目录路径，注意，</p><p>‘D:\Jupyter’ 中不能有空格，否则Jupyter 打开就闪退。保存后关闭。</p><p>⑥ 找到桌面的 jupyter notebook 快捷图标，鼠标反键&gt;&gt;属性&gt;&gt;快捷方式&gt;&gt;目标，删除最后的”%USERPROFILE%&#x2F;“。</p><h2 id="3-4-修改-Jupyter-字体"><a href="#3-4-修改-Jupyter-字体" class="headerlink" title="3.4  修改 Jupyter 字体"></a>3.4  修改 Jupyter 字体</h2><p>初始字体可以进行修改，修改流程如下。</p><p>① 打开如下地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Anaconda\Lib\site-packages\notebook\static\components\codemirror\lib</span><br></pre></td></tr></table></figure><p>② 打开codemirror.css 文件；</p><p>③ Ctrl+F，搜索“font-family: monospace;”的文字，并将其改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font-family: &#x27;Fira Code Light&#x27;,&#x27;Consolas&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改完后，如图 3-4 所示。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image033.jpg" alt="img"></td></tr></tbody></table><p>图 3-4 修改Jupyter 字体</p><h1 id="四、Anaconda-虚拟环境"><a href="#四、Anaconda-虚拟环境" class="headerlink" title="四、Anaconda 虚拟环境"></a>四、Anaconda 虚拟环境</h1><p>在 2022.10 版本的 Anaconda 中，其 base 环境中主要几个库的版本分别是： Python 3.9、NumPy 1.21.5、Pandas 1.2.4、Matplotlib 3.5.1。当然，Anaconda 的base环境中的库非常非常多，这只是深度学习需要的几个。</p><p>很多时候我们需要复刻其它演示代码中的环境，因此，虚拟环境必须掌握。虚拟环境想创建多少个，就创建多少，而且初始的虚拟环境基本没什么库，演示代码里说需要什么版本的库，我们就手动安装什么版本的库。</p><h2 id="4-1-虚拟环境基础命令"><a href="#4-1-虚拟环境基础命令" class="headerlink" title="4.1  虚拟环境基础命令"></a>4.1  虚拟环境基础命令</h2><p>点击Prompt 进入 Anaconda 的环境中，接下来的命令均在Prompt 中执行。</p><p><strong>（1）</strong> <strong>Prompt</strong> <strong>清屏</strong></p><table><thead><tr><th># 清屏</th></tr></thead><tbody><tr><td>cls</td></tr></tbody></table><p><strong>（2）</strong> <strong>base</strong> <strong>环境下的操作</strong></p><table><thead><tr><th># 列出所有的虚拟环境</th></tr></thead><tbody><tr><td>conda env list</td></tr><tr><td></td></tr><tr><td># 创建名为“环境名”的虚拟环境，并指定Python 解释器的版本</td></tr><tr><td>conda create  -n 环境名 python&#x3D;3.9</td></tr><tr><td></td></tr><tr><td># 删除名为“环境名”的虚拟环境</td></tr><tr><td>conda remove -n 环境名 –all</td></tr><tr><td></td></tr><tr><td># 进入名为“环境名”的虚拟环境</td></tr><tr><td>conda activate 环境名</td></tr></tbody></table><p><strong>（3）</strong> <strong>虚拟环境内的操作</strong></p><p><strong>（****pip</strong> <strong>安装若<strong><strong>失败，</strong></strong>在<strong><strong>【</strong></strong>pip</strong> <strong>intsall</strong> <strong>库</strong>**&#x3D;&#x3D;<strong><strong>版本】后加【</strong> <strong>-i</strong> <strong><a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></strong> <strong>】即可</strong></strong>）**</p><table><thead><tr><th># 列出当前环境下的所有库</th></tr></thead><tbody><tr><td>conda list</td></tr><tr><td></td></tr><tr><td># 安装NumPy 库，并指定版本 1.12.5</td></tr><tr><td>pip install  numpy&#x3D;&#x3D;1.21.5 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></td></tr><tr><td></td></tr><tr><td># 安装Pandas 库，并指定版本 1.2.4</td></tr><tr><td>pip install  Pandas&#x3D;&#x3D;1.2.4 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></td></tr><tr><td></td></tr><tr><td># 安装Matplotlib 库，并指定版本 3.5.1</td></tr><tr><td>pip install  Matplotlib&#x3D;&#x3D;3.5.1 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></td></tr><tr><td></td></tr><tr><td># 查看当前环境下某个库的版本（以numpy 为例）</td></tr><tr><td>pip show numpy</td></tr><tr><td></td></tr><tr><td># 退出虚拟环境</td></tr><tr><td>conda deactivate</td></tr></tbody></table><h2 id="4-2-虚拟环境连接-Jupyter-内核"><a href="#4-2-虚拟环境连接-Jupyter-内核" class="headerlink" title="4.2  虚拟环境连接 Jupyter 内核"></a>4.2  虚拟环境连接 Jupyter 内核</h2><p>经 4.1 小节，我们在 Anaconda 里创建了一个叫 DL 的虚拟环境，并在其中安装了数据科学三大基库——Numpy 数组库、Pandas 标签库、Matplotlib 绘图库。但是现在这个叫 DL 的虚拟环境没有连接 Jupyter 内核，换句话说，Jupyter</p><p>现在只有与base 环境相连。</p><p>为让虚拟环境与 Jupyter 内核相连，请在 Prompt 的虚拟环境下操作下列命令。<strong>若列出</strong> <strong>Jupyter</strong> <strong>的内核列表时反馈****“Jupyter</strong> <strong>不是内部或外部命令<strong><strong>”</strong></strong>，则先操作后面两步，再回头列出</strong> <strong>Jupyter</strong> <strong>的内核列表即可。</strong></p><table><thead><tr><th># 列出Jupyter 的内核列表</th></tr></thead><tbody><tr><td>jupyter kernelspec list</td></tr><tr><td></td></tr><tr><td># 安装ipykernel</td></tr><tr><td>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> ipykernel</td></tr><tr><td></td></tr><tr><td># 将虚拟环境导入Jupyter 的kernel 中</td></tr><tr><td>python -m ipykernel install –user –name&#x3D;环境名</td></tr><tr><td></td></tr><tr><td># 删除虚拟环境的kernel 内核</td></tr><tr><td>jupyter kernelspec remove 环境名</td></tr></tbody></table><h1 id="五、安装-GPU-版本的-PyTorch-库"><a href="#五、安装-GPU-版本的-PyTorch-库" class="headerlink" title="五、安装 GPU 版本的 PyTorch 库"></a>五、安装 GPU 版本的 PyTorch 库</h1><p>PyTorch 虽然是一个库，但安装时的核心组件叫 torch，还额外有两个小组件： torchvision 和torchaudio。</p><p>由于PyTorch 库的下载组件内部含有cudatoolkit，它是 CUDA 的子集，里面的东西足够PyTorch 使用，因此本教程不用单独安装 CUDA 和CUDNN，也不用考虑PyTorch 内置cuda 与计算机显卡 CUDA 版本之间的关系（已亲测）。</p><p>本计算机的CUDA 版本为 11.1，如图 5-1，后续直接安装内置 cuda11.3 版本的torch。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image035.jpg" alt="img"></p><p>图 5-1 本机CUDA 版本不重要</p><p>下面是演示，尽量选择和自己本地CUDA版本一致的CUDA Tookit安装。</p><p>(1)选择安装版本:<br>首先打开自己电脑上的NVIDIA控制面板,点击系统信息。</p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426020224611.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426020224611.png" alt="image-20230426020224611"></a></p><p>(2) 到<a href="https://developer.nvidia.com/cuda-downloads">CUDA官网</a>,点击这里</p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426020353790.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426020353790.png" alt="image-20230426020353790"></a></p><p>这里我选择的是10.1版本的CUDA。</p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426025346518.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426025346518.png" alt="image-20230426025346518"></a></p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426021229017.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426021229017.png" alt="image-20230426021229017"></a></p><p>新建文件夹类似这种。</p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426022615732.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426022615732.png" alt="image-20230426022615732"></a></p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426173617454.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426173617454.png" alt="image-20230426173617454"></a></p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174219077.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174219077.png" alt="image-20230426174219077"></a></p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174259234.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174259234.png" alt="image-20230426174259234"></a></p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174439408.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174439408.png" alt="image-20230426174439408"></a></p><p><a href="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174506080.png"><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174506080.png" alt="image-20230426174506080"></a></p><h2 id="5-1-基本的-GPU-概念"><a href="#5-1-基本的-GPU-概念" class="headerlink" title="5.1  基本的 GPU 概念"></a>5.1  基本的 GPU 概念</h2><p>对于计算机而言，中央处理器CPU 是主板上的一块芯片，图形处理器 GPU</p><p>是显卡上的一块芯片。每台计算机必有主板，但少数计算机可能没有显卡。</p><p>显卡的全称是“显示适配器”，显卡最初被发明是单纯为了大型 3D 游戏用，后来被发现还可以用来顺带加速PyTorch 的运行速度（比CPU 快 10-100 倍）。</p><p>查看自己的计算机的显卡为：任务管理器——性能——左侧栏划到最下面。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image037.jpg" alt="img"></td></tr></tbody></table><p>图 5-2 查看显卡</p><p>NVIDIA 的独立显卡必须有！而且只能是 NVIDIA，不能是其他牌子。没有 NVIDIA 显卡的同学也没事，经测试，可以跟我们一起安装 GPU 版本的PyTorch，只不过torch.cuda.is_available( )命令返回false（也就是无法使用显卡的意思）。</p><h2 id="5-2-安装-PyTorch"><a href="#5-2-安装-PyTorch" class="headerlink" title="5.2  安装 PyTorch"></a>5.2  安装 PyTorch</h2><p>安装torch 前，先给出一张推荐表，其中 cu113 即torch 内部的cudatoolkit 是</p><p>cuda 11.3 版本。所需的 Python 版本优先选择 3.9，除非演示代码告知具体版本。表 5-1 目前所有torch 版本的推荐按照表</p><table><thead><tr><th>torch 版本</th><th>推荐的内置cuda  版本</th><th>所需的Python  版本</th></tr></thead><tbody><tr><td>torch 1.13.1</td><td>cu116</td><td>3.7、3.8、3.9、3.10</td></tr><tr><td>torch 1.13.0</td><td>cu116</td><td>3.7、3.8、3.9、3.10</td></tr><tr><td>torch 1.12.1</td><td>cu113</td><td>3.7、3.8、3.9、3.10</td></tr><tr><td>torch 1.12.0</td><td>cu113</td><td>3.7、3.8、3.9、3.10</td></tr><tr><td>torch 1.11.0</td><td>cu113</td><td>3.7、3.8、3.9、3.10</td></tr><tr><td>torch 1.10.2</td><td>cu113</td><td>3.6、3.7、3.8、3.9</td></tr><tr><td>torch 1.10.1</td><td>cu113</td><td>3.6、3.7、3.8、3.9</td></tr><tr><td>torch 1.10.0</td><td>cu113</td><td>3.6、3.7、3.8、3.9</td></tr><tr><td>torch 1.9.1</td><td>cu111</td><td>3.6、3.7、3.8、3.9</td></tr><tr><td>torch 1.9.0</td><td>cu111</td><td>3.6、3.7、3.8、3.9</td></tr><tr><td>torch 1.8.1</td><td>cu111</td><td>3.6、3.7、3.8、3.9</td></tr><tr><td>torch 1.8.0</td><td>cu111</td><td>3.6、3.7、3.8、3.9</td></tr><tr><td>torch 1.7.1</td><td>cu110</td><td>3.6、3.7、3.8、3.9</td></tr><tr><td>torch 1.7.0</td><td>cu110</td><td>3.6、3.7、3.8</td></tr><tr><td>torch 1.6.0</td><td>cu101</td><td>3.6、3.7、3.8</td></tr><tr><td>torch 1.5.1</td><td>cu101</td><td>3.5、3.6、3.7、3.8</td></tr><tr><td>torch 1.5.0</td><td>cu101</td><td>3.5、3.6、3.7、3.8</td></tr></tbody></table><p>注：英伟达显卡 30 系列（如 NVIDIA GeForce RTX 3050）只能 cuda11.0 及其以上的版本。</p><p>现假设某个演示代码中所安装的 torch 是 1.12.0 版本（给定了 torch 版本后， torchvision 和 torchaudio 也唯一确定了），根据表 5-1，推荐的内置 cuda 是 11.3，优先选择python 3.9 版本，进入PyTorch 官网：</p><blockquote><p><a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></p></blockquote><p>在其中Ctrl + F 搜索【 pip install torch&#x3D;&#x3D;1.12.0 】，如图 5-3 所示。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image040.jpg" alt="img"></td></tr></tbody></table><p>图 5-3 搜索结果</p><h2 id="（1）-方法一：直接法"><a href="#（1）-方法一：直接法" class="headerlink" title="（1） 方法一：直接法"></a>（1） 方法一：直接法</h2><p>复制网页里的那段代码，也即</p><p>pip install torch&#x3D;&#x3D;1.12.0+cu113 torchvision&#x3D;&#x3D;0.13.0+cu113 torchaudio&#x3D;&#x3D;0.12.0 –extra-index-url <a href="https://download.pytorch.org/whl/cu113">https://download.pytorch.org/whl/cu113</a></p><p>双击Prompt，进入Python 3.9 的虚拟环境DL 下运行，如图 5-4。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image042.jpg" alt="img"></td></tr></tbody></table><p>图 5-4 虚拟环境下安装torch</p><p>看到最后几行代码里有Successfully installed 就算成功。</p><h2 id="（2）-方法二：轮子法"><a href="#（2）-方法二：轮子法" class="headerlink" title="（2） 方法二：轮子法"></a>（2） 方法二：轮子法</h2><p>按视频中的方式下载轮子文件，或进入 QQ 群，在群文件中下载。下载好后，将三个 whl 文件放在新建的 D:\whl 文件夹中。</p><p>安装命令为（以下命令在Prompt 的虚拟环境DL 中执行）：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image043.gif" alt="文本框: pip install D:\whl\torch-1.12.0+cu113-cp39-cp39-win_amd64.whl pip install D:\whl\torchvision-0.13.0+cu113-cp39-cp39-win_amd64.whl pip install D:\whl\torchaudio-0.12.0+cu113-cp39-cp39-win_amd64.whl "></td></tr></tbody></table><p>这三行代码的结构都是：pip install 路径\轮子名.whl 。</p><h2 id="5-3-检验-PyTorch-是否安装成功"><a href="#5-3-检验-PyTorch-是否安装成功" class="headerlink" title="5.3  检验 PyTorch 是否安装成功"></a>5.3  检验 PyTorch 是否安装成功</h2><p>接下来的操作，可以在Prompt 里以直接运行Python 解释器的方式检验，也可以在Jupyter 代码编辑器里检验。</p><h2 id="（1）-直接在-Python-解释器里检验"><a href="#（1）-直接在-Python-解释器里检验" class="headerlink" title="（1） 直接在 Python 解释器里检验"></a>（1） 直接在 Python 解释器里检验</h2><p>首先，进入虚拟环境DL 后，输入python 以进入解释器，如图 5-5。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image045.jpg" alt="img"></td></tr></tbody></table><p>图 5-5 进入DL 虚拟环境的python 解释器</p><p>输入import torch 导入torch 库，如图 5-6 所示。若安装失败，则会返回No module named ‘torch’。若安装成功，不会返回任何语句，同时在下一行出现“&gt;&gt;&gt;”，提示我们可以继续敲代码。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image047.jpg" alt="img"></p><p>图 5-6 测试torch 是否可以导入</p><p>最后一步，输入torch.cuda.is_available()，如图 5-7 所示。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image049.jpg" alt="img"></td></tr></tbody></table><p>图 5-7 测试torch 是否能连接cuda</p><p>如果你是CPU 用户，那么会返回 false，这对你来说是正常现象。但对于 GPU</p><p>用户来说应当返回True。</p><h2 id="（2）-在-Jupyter-代码编辑器里检验"><a href="#（2）-在-Jupyter-代码编辑器里检验" class="headerlink" title="（2） 在 Jupyter 代码编辑器里检验"></a>（2） 在 Jupyter 代码编辑器里检验</h2><p>在Jupyter 里，切换到DL 内核后，输入两段代码后运行，如图 5-8 所示。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/clip_image051.jpg" alt="img"></td></tr></tbody></table><p>图 5-8 Jupyter 替代Prompt</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-Anaconda配置</title>
      <link href="/article/6b7afcc8.html"/>
      <url>/article/6b7afcc8.html</url>
      
        <content type="html"><![CDATA[<p>Aconda</p><h2 id="一、什么是Anaconda？"><a href="#一、什么是Anaconda？" class="headerlink" title="一、什么是Anaconda？"></a><strong>一、什么是Anaconda？</strong></h2><p><strong>1. 简介</strong></p><p>Anaconda（<a href="https://link.zhihu.com/?target=https://www.anaconda.com/download/%23macos">官方网站</a>）就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</p><p><strong>2. 特点</strong></p><p>Anaconda具有如下特点：</p><p>▪ 开源</p><p>▪ 安装过程简单</p><p>▪ 高性能使用Python和R语言</p><p>▪ 免费的社区支持</p><p>其特点的实现主要基于Anaconda拥有的：</p><p>▪ conda包</p><p>▪ 环境管理器</p><p>▪ 1,000+开源库</p><p>如果日常工作或学习并不必要使用1,000多个库，那么可以考虑安装Miniconda（<a href="https://link.zhihu.com/?target=https://conda.io/miniconda.html">下载界面请戳</a>），这里不过多介绍Miniconda的安装及使用。</p><p><strong>3. Anaconda、conda、pip、virtualenv的区别</strong></p><p><strong>① Anaconda</strong></p><p>Anaconda是一个包含180+的科学包及其依赖项的发行版本。其包含的科学包包括：conda, numpy, scipy, ipython notebook等。</p><p><strong>② conda</strong></p><p>conda是包及其依赖项和环境的管理工具。</p><p>▪ 适用语言：Python, R, Ruby, Lua, Scala, Java, JavaScript, C&#x2F;C++, FORTRAN。</p><p>▪ 适用平台：Windows, macOS, Linux</p><p>▪ 用途：</p><p>① 快速安装、运行和升级包及其依赖项。</p><p>② 在计算机中便捷地创建、保存、加载和切换环境。</p><blockquote><p>如果你需要的包要求不同版本的Python，你无需切换到不同的环境，因为conda同样是一个环境管理器。仅需要几条命令，你可以创建一个完全独立的环境来运行不同的Python版本，同时继续在你常规的环境中使用你常用的Python版本。——<a href="https://link.zhihu.com/?target=https://conda.io/docs/">Conda官方网站</a></p></blockquote><p>▪ conda为Python项目而创造，但可适用于上述的多种语言。</p><p>▪ conda包和环境管理器包含于Anaconda的所有版本当中。</p><p><strong>③ pip</strong></p><p>pip是用于安装和管理软件包的包管理器。</p><p>▪ pip编写语言：Python。</p><p>▪ Python中默认安装的版本：</p><p>① Python 2.7.9及后续版本：默认安装，命令为 *<strong>pip*</strong></p><p>② Python 3.4及后续版本：默认安装，命令为 *<strong>pip3*</strong></p><p>▪ pip名称的由来：pip采用的是<strong>递归缩写</strong>进行命名的。其名字被普遍认为来源于2处：</p><p>① “Pip installs Packages”（“pip安装包”）</p><p>② “Pip installs Python”（“pip安装Python”）</p><p><strong>④ virtualenv</strong></p><p>virtualenv是用于创建一个<strong>独立的</strong>Python环境的工具。</p><p>▪ 解决问题：</p><ol><li>当一个程序需要使用Python 2.7版本，而另一个程序需要使用Python 3.6版本，如何同时使用这两个程序？如果将所有程序都安装在系统下的默认路径，如：***&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;site-packages***，当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。</li><li>如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。</li><li>在共享主机时，无法在全局 *<strong>site-packages*</strong> 目录中安装包。</li></ol><p>▪ virtualenv将会为它自己的安装目录创建一个环境，这并<strong>不与</strong>其他virtualenv环境共享库；同时也可以<strong>选择性</strong>地不连接已安装的全局库。</p><p><strong>⑤ pip 与 conda 比较</strong></p><p><strong>→ 依赖项检查</strong></p><p>▪ pip：</p><p>① <strong>不一定</strong>会展示所需其他依赖包。</p><p>② 安装包时<strong>或许</strong>会直接忽略依赖项而安装，仅在结果中提示错误。</p><p>▪ conda：</p><p>① 列出所需其他依赖包。</p><p>② 安装包时自动安装其依赖项。</p><p>③ 可以便捷地在包的不同版本中自由切换。</p><p><strong>→ 环境管理</strong></p><p>▪ pip：维护多个环境难度较大。</p><p>▪ conda：比较方便地在不同环境之间进行切换，环境管理较为简单。</p><p><strong>→ 对系统自带Python的影响</strong></p><p>▪ pip：在系统自带Python中包的更新&#x2F;回退版本&#x2F;卸载将影响其他程序。</p><p>▪ conda：不会影响系统自带Python。</p><p><strong>→ 适用语言</strong></p><p>▪ pip：仅适用于Python。</p><p>▪ conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C&#x2F;C++, FORTRAN。</p><p><strong>⑥ conda与pip、virtualenv的关系</strong></p><p>▪ conda<strong>结合</strong>了pip和virtualenv的功能。</p><h2 id="二、Anaconda的适用平台及安装条件"><a href="#二、Anaconda的适用平台及安装条件" class="headerlink" title="二、Anaconda的适用平台及安装条件"></a><strong>二、Anaconda的适用平台及安装条件</strong></h2><p><strong>1. 适用平台</strong></p><p>Anaconda可以在以下系统平台中安装和使用：</p><p>▪ Windows</p><p>▪ macOS</p><p>▪ Linux（x86 &#x2F; Power8）</p><p><strong>2. 安装条件</strong></p><p>▪ 系统要求：32位或64位系统均可</p><p>▪ 下载文件大小：约500MB</p><p>▪ 所需空间大小：3GB空间大小（Miniconda仅需400MB空间即可）</p><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><p>添加清华镜像包管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes  #展示包的地址</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加PyTorch清华镜像（可选）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud//pytorch/</span><br></pre></td></tr></table></figure><p>切回默认源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><p>conda环境配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装环境  conda create -n pyG python=3.6</span><br><span class="line">删除环境  conda remove -n #env --all</span><br><span class="line">激活环境  conda activate #env</span><br><span class="line">退出环境  conda deactivate </span><br></pre></td></tr></table></figure><h2 id="四、配置pyTorch环境"><a href="#四、配置pyTorch环境" class="headerlink" title="四、配置pyTorch环境"></a>四、配置pyTorch环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pyG python=3.6     #安装环境名称是pyG, python版本是3.6</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426013101689.png" alt="image-20230426013101689"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426013204459.png" alt="image-20230426013204459"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda  activate pyG   #激活安装的环境</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426013816400.png" alt="image-20230426013816400"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate  #退出环境</span><br></pre></td></tr></table></figure><p>安装pyG之前，需要看版本适配。</p><p><a href="https://pytorch-geometric.readthedocs.io/en/1.4.3/notes/installation.html">https://pytorch-geometric.readthedocs.io/en/1.4.3/notes/installation.html</a></p><p>pytorch安装指南：</p><p><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==1.4.0 torchvision==0.5.0 cudatoolkit=10.1 -c pytorch</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426025001840.png" alt="image-20230426025001840"></p><p>上面是安装的对应cuda10.0的版本。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426025236942.png" alt="image-20230426025236942"></p><p>报错解决方法：<a href="https://blog.csdn.net/weixin_45552562/article/details/109668589?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168244741716800186511605%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168244741716800186511605&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109668589-null-null.142%5Ev86%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&utm_term=%20PackagesNotFoundError:%20The%20following%20packages%20are%20not%20available%20from%20current%20channels:%20%20%20%20-%20pytorch==1.2.0%20%20%20-%20torchvision==0.4.0&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_45552562/article/details/109668589?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168244741716800186511605%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168244741716800186511605&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109668589-null-null.142^v86^insert_down1,239^v2^insert_chatgpt&amp;utm_term=%20PackagesNotFoundError%3A%20The%20following%20packages%20are%20not%20available%20from%20current%20channels%3A%20%20%20%20-%20pytorch%3D%3D1.2.0%20%20%20-%20torchvision%3D%3D0.4.0&amp;spm=1018.2226.3001.4187</a></p><p>首先要确保你安装的cuda版本是10.1.</p><p>(1)选择安装版本:<br>首先打开自己电脑上的NVIDIA控制面板,点击系统信息。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426020224611.png" alt="image-20230426020224611"></p><p>(2) 到<a href="https://developer.nvidia.com/cuda-downloads">CUDA官网</a>,点击这里</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426020353790.png" alt="image-20230426020353790"></p><p>这里我选择的是10.1版本的CUDA。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426025346518.png" alt="image-20230426025346518"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426021229017.png" alt="image-20230426021229017"></p><p>新建文件夹类似这种。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426022615732.png" alt="image-20230426022615732"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426173617454.png" alt="image-20230426173617454"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174219077.png" alt="image-20230426174219077"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174259234.png" alt="image-20230426174259234"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174439408.png" alt="image-20230426174439408"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230426174506080.png" alt="image-20230426174506080"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sdn实验-OpenDaylight控制器的安装与使用</title>
      <link href="/article/65be8feb.html"/>
      <url>/article/65be8feb.html</url>
      
        <content type="html"><![CDATA[<p>sdn实验-OpenDaylight控制器的安装与使用</p><blockquote><p>OpenDaylight自发布以来就备受用户喜爱，这不仅仅是因为它功能强大，还因为其设计非常注重美学和视觉体验，OpenDaylight提供了非常美观且功能完善的可视化管理界面，方便用户进行网络拓扑管理及自定义开发，站在用户角度去考虑的方式，也为其赢得了众多忠实用户。OpenDaylight控制器的版本号命名方式也体现着独特的审美，与常见使用数字或者希腊字母为编号的方式不同，它以化学元素周期表中的元素名称作为版本号，本例中使用OpenDaylight氮版本。</p></blockquote><p>本文章的内容：</p><blockquote><p>1.安装JAVA环境</p><p>2.安装OpenDaylight</p><p>3.验证OpenDaylight是否安装成功</p></blockquote><h1 id="1-安装JAVA环境"><a href="#1-安装JAVA环境" class="headerlink" title="1.安装JAVA环境"></a>1.安装JAVA环境</h1><h2 id="1-1安装JDK"><a href="#1-1安装JDK" class="headerlink" title="1.1安装JDK"></a>1.1安装JDK</h2><p><code>sudo apt-get install openjdk-版本号-jdk -y</code></p><p><code>例如安装JDK8版本：sudo apt-get install openjdk-8-jdk</code></p><p>更新环境变量</p><p><code>sudo gedit ~/.bashrc</code></p><p>在最后添加</p><blockquote><p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64<br>export JRE_HOME&#x3D;${JAVA_HOME}&#x2F;jre<br>export CLASSPATH&#x3D;.:${JAVA_HOME}&#x2F;lib:${JRE_HOME}&#x2F;lib<br>export PATH&#x3D;${JAVA_HOME}&#x2F;bin:$PATH</p></blockquote><p>更新</p><p><code>source ~/.bashrc</code></p><p>设置Java环境变量</p><p>sudo gedit  &#x2F;etc&#x2F;environment</p><p>JAVA_HOME&#x3D;”exit&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-8-openjdk-amd64”</p><p>再安装Maven，查看maven的可安装版本。</p><p><code>sudo apt policy maven</code></p><p>开始安装maven</p><p><code>sudo apt install maven</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415152328410.png" alt="image-20230415152328410"></p><h1 id="2-安装OpenDaylight"><a href="#2-安装OpenDaylight" class="headerlink" title="2.安装OpenDaylight"></a>2.安装OpenDaylight</h1><h3 id="2-1下载OpenDaylight"><a href="#2-1下载OpenDaylight" class="headerlink" title="2.1下载OpenDaylight"></a>2.1下载OpenDaylight</h3><blockquote><p>在OpenDaylight网站下载，<a href="https://docs.opendaylight.org/en/latest/downloads.html">https://docs.opendaylight.org/en/latest/downloads.html</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415153427049.png" alt="image-20230415153427049"></p><h3 id="2-2解压"><a href="#2-2解压" class="headerlink" title="2.2解压"></a>2.2解压</h3><p>把下载好的karaf-0.7.1.zip文件解压。</p><blockquote><p>cd  &#x2F;home&#x2F;sz</p><p>ls</p><p>unzip karaf-0.7.1.zip</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230415155451047.png" alt="image-20230415155451047"></p><h3 id="2-3修改参数-这一步先不做，容易出错，先启动karf看是否正常"><a href="#2-3修改参数-这一步先不做，容易出错，先启动karf看是否正常" class="headerlink" title="2.3修改参数(这一步先不做，容易出错，先启动karf看是否正常)"></a>2.3修改参数(这一步先不做，容易出错，先启动karf看是否正常)</h3><blockquote><p><code>cd /home/sz/karaf-0.7.1/etc</code></p><p><code>sudo gedit org.apache.karaf.management.cfg</code></p><p>在org.apache.karaf.management.cfg文件中修改一下两行内容</p><p>rmiRegisryHost &#x3D; 127.0.0.1 #在32行</p><p>rmiServerHost &#x3D; 127.0.0.1 #在42行</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230415160247552.png" alt="image-20230415160247552"></p><h3 id="24-启动Karaf"><a href="#24-启动Karaf" class="headerlink" title="24.启动Karaf"></a>24.启动Karaf</h3><p><code>cd /home/sz/karaf-0.7.1/bin</code></p><p><code>sudo ./karaf</code></p><blockquote><p>注：Karaf为openDaylight的容器，退出Karaf的命令是logout。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415164711784.png" alt="image-20230415164711784"></p><h3 id="2-5安装feature"><a href="#2-5安装feature" class="headerlink" title="2.5安装feature"></a>2.5安装feature</h3><p>在上图的界面 ，输入<code>feature:install odl-restconf</code></p><p><code>feature:install odl-l2switch-switch-ui</code></p><p><code>feature:install odl-mdsal-apidocs</code></p><p><code>feature:install odl-dluxapps-applications</code></p><p>输出中 <code>feature</code> 字样变成了红色，表示此命令的语法存在问题或命令未被正确识别。</p><p>我的解决办法是更换新的karaf版本，并且使用JDK17版本。</p><h1 id="3-验证OpenDaylight控制器是否安装成功"><a href="#3-验证OpenDaylight控制器是否安装成功" class="headerlink" title="3.验证OpenDaylight控制器是否安装成功"></a>3.验证OpenDaylight控制器是否安装成功</h1><h2 id="3-1启动OpenDaylight控制器"><a href="#3-1启动OpenDaylight控制器" class="headerlink" title="3.1启动OpenDaylight控制器"></a>3.1启动OpenDaylight控制器</h2><p><code>cd /home/sz/karaf-0.7.1/bin</code></p><p><code>sudo ./karaf</code></p><h2 id="3-2登录OpenDaylight管理界面"><a href="#3-2登录OpenDaylight管理界面" class="headerlink" title="3.2登录OpenDaylight管理界面"></a>3.2登录OpenDaylight管理界面</h2><blockquote><p>打开Ubuntu中的浏览器，输入网址：http:&#x2F;&#x2F;<yourMachineIp>:8181&#x2F;index.html</p><p>用户名和密码都是admin</p><p>举例：虚拟机IP地址为192.168.65.128，则输入网址：</p><p><a href="http://192.168.65.128:8181/index.html">http://192.168.65.128:8181/index.html</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230415224910277.png" alt="image-20230415224910277"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230415225012400.png" alt="image-20230415225012400"></p><h2 id="3-3启动mininet创建最小化网络拓扑"><a href="#3-3启动mininet创建最小化网络拓扑" class="headerlink" title="3.3启动mininet创建最小化网络拓扑"></a>3.3启动mininet创建最小化网络拓扑</h2><p><code>sudo mn --controller=remote</code> </p><p><code>pingall</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed1@main/img/image-20230415225607940.png" alt="image-20230415225607940"></p><h2 id="3-4在OpenDaylight管理界面中查看当前网络拓扑"><a href="#3-4在OpenDaylight管理界面中查看当前网络拓扑" class="headerlink" title="3.4在OpenDaylight管理界面中查看当前网络拓扑"></a>3.4在OpenDaylight管理界面中查看当前网络拓扑</h2><p>​</p><blockquote><p>点击OpenDaylight管理界面左侧的“Topology”选项</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SDN实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDN实验（基于Ubuntu20.04）Mininet和Ryu安装</title>
      <link href="/article/90aa8a04.html"/>
      <url>/article/90aa8a04.html</url>
      
        <content type="html"><![CDATA[<p>SDN实验（基于Ubuntu20.04）Mininet和Ryu安装</p><h1 id="Mininet安装"><a href="#Mininet安装" class="headerlink" title="Mininet安装"></a>Mininet安装</h1><ul><li><p>Mininet是一个开源的网络仿真器，是一个轻量级软件定义网络和测试平台，支持OpenFlow、</p></li><li><p>OpenvSwith 等各种协议。</p></li><li><p>使用Mininet可以很方便地创建一个支持SDN的网络。用户可以自定义网络拓扑，灵活地为网络添加新的功能并进行相关测试，从而缩短开发测试周期。在Mininet 上运行的代码可以轻松移植到支持OpenFlow的硬件设备上。</p></li><li><p>Mininet可以在自己的电脑，或服务器，或虚拟机，或者云（例如AmazonEC2）上运行。</p></li><li><p>Mininet提供 python APl，简单易用。</p></li></ul><blockquote><p>1.登录sz用户,sudo.</p><p>2.安装git</p><p>3.下载mininet源代码</p><p>4.安装mininet</p></blockquote><h1 id="1-登录sz用户-sudo"><a href="#1-登录sz用户-sudo" class="headerlink" title="1.登录sz用户,sudo."></a>1.登录sz用户,sudo.</h1><p><code>首先进入 /home/sz目录</code></p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/image-20230414213700827.png" alt="image-20230414213700827"></p><h2 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h2><p><code>sudo apt-get install git #安装git</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414213934841.png" alt="image-20230414213934841"></p><h2 id="3-下载mininet源代码"><a href="#3-下载mininet源代码" class="headerlink" title="3.下载mininet源代码"></a>3.下载mininet源代码</h2><p><code>git clone https://github.com/mininet/mininet.git #安装mininet源代码</code></p><blockquote><p>注意：重新进入&#x2F;home&#x2F;sz目录（sz是你的用户名），因为刚才sudo进入root权限，之后git clone的文件夹是root用户所有，不方便在图形化界面修改。</p></blockquote><blockquote><p>Ubuntu终端以及浏览器连接不上Github的解决办法：<a href="https://blog.csdn.net/voshv/article/details/127120400?ops_request_misc=&request_id=&biz_id=102&utm_term=ubtuntu20.04%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86GitHub&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-127120400.142%5Ev83%5Einsert_down1,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">https://blog.csdn.net/voshv/article/details/127120400?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=ubtuntu20.04%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86GitHub&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-127120400.142^v83^insert_down1,239^v2^insert_chatgpt&amp;spm=1018.2226.3001.4187</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414215116888.png" alt="image-20230414215116888"></p><h2 id="4-安装mininet"><a href="#4-安装mininet" class="headerlink" title="4.安装mininet"></a>4.安装mininet</h2><p><code>安装mininet</code></p><blockquote><p>cd  mininet</p><p>ls</p><p>cd util</p><p>ls</p><p>.&#x2F;install.sh </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415141302345.png" alt="image-20230415141302345"></p><p>出现这个界面是安装成功，期间会git clone很多库，如果克隆失败，可以用dev-sidecar。</p><p>如果上一步安装openvswitch不成功</p><p>可以执行  <code>sudo apt-get install openvswitch-switch</code></p><p>第二步</p><p><code>ovs-vsctl show</code></p><h1 id="Ryu安装"><a href="#Ryu安装" class="headerlink" title="Ryu安装"></a>Ryu安装</h1><blockquote><p>1.安装pip</p><p>2.下载Ryu源代码</p><p>3.安装Ryu依赖包</p><p>4.安装Ryu</p><p>5.验证Ryu是否安装成功</p></blockquote><h2 id="1-安装pip"><a href="#1-安装pip" class="headerlink" title="1.安装pip"></a>1.安装pip</h2><p>最好在根目录安装</p><p><code>cd /home/sz</code></p><p><code>wget https://bootstrap.pypa.io/get-pip.py</code></p><p><code>ls #查看文件是否安装完</code></p><p><code>sudo python3 get-pip.py #使用python3安装 </code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414235804873.png" alt="image-20230414235804873"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414235956809.png" alt="image-20230414235956809"></p><h2 id="2-下载Ryu源代码"><a href="#2-下载Ryu源代码" class="headerlink" title="2.下载Ryu源代码"></a>2.下载Ryu源代码</h2><p>将ryu源码下载到虚拟机：</p><p><code>git clone https://github.com/osrg/ryu.git</code></p><blockquote><p>本例ryu源代码下载到了&#x2F;home&#x2F;sz&#x2F;ryu目录下</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415000343641.png" alt="image-20230415000343641"></p><h2 id="3-安装Ryu依赖包"><a href="#3-安装Ryu依赖包" class="headerlink" title="3.安装Ryu依赖包"></a>3.安装Ryu依赖包</h2><p>首先进入ryu目录</p><p><code>cd /home/sz/ryu</code></p><p><code>sudo pip install -r tools/pip-requires</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415000640915.png" alt="image-20230415000640915"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415000715233.png" alt="image-20230415000715233"></p><p>出现报错则重新执行命令</p><h2 id="4-安装Ryu"><a href="#4-安装Ryu" class="headerlink" title="4.安装Ryu"></a>4.安装Ryu</h2><p><code>cd /home/sz/ryu</code></p><p><code>sudo python3 setup.py install</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415000957618.png" alt="image-20230415000957618"></p><h2 id="5-验证Ryu是否安装成功"><a href="#5-验证Ryu是否安装成功" class="headerlink" title="5.验证Ryu是否安装成功"></a>5.验证Ryu是否安装成功</h2><p>进入ryu&#x2F;ryu&#x2F;app目录</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415001053693.png" alt="image-20230415001053693"></p><p><code>sudo ryu-manager example_switch_13.py#使用switch_</code>的模板文件</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415143654941.png" alt="image-20230415143654941"></p><p>接下来打开mininet创建网络拓扑</p><p>打开另一个终端</p><p><code>sudo mn --controller=remote #mn创建最小的网络拓扑，controller=remote使用远程控制器即ryu控制器  </code></p><p>如果不输入controller&#x3D;remote则使用mininet自带的控制器。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415144007867.png" alt="image-20230415144007867"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230415144656302.png" alt="image-20230415144656302"></p><p>这样就是正常，mininet输入exit退出，ryu按住ctrl+c退出。</p>]]></content>
      
      
      <categories>
          
          <category> SDN实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDN实验-Mininet常用命令和Mininet创建网络拓扑</title>
      <link href="/article/a997af82.html"/>
      <url>/article/a997af82.html</url>
      
        <content type="html"><![CDATA[<p><strong>SDN实验-Mininet常用命令和Mininet创建网络拓扑</strong></p><ul><li>Mininet是一个开源的网络仿真器，是一个轻量级软件定义网络和测试平台，支持OpenFlow、<br>OpenvSwith 等各种协议。</li><li>使用Mininet可以很方便地创建一个支持SDN的网络。用户可以自定义网络拓扑，灵活地为网络添加新的功能并进行相关测试，从而缩短开发测试周期。在Mininet 上运行的代码可以轻松移植到支持OpenFlow的硬件设备上。</li><li>Mininet可以在自己的电脑，或服务器，或虚拟机，或者云（例如AmazonEC2）上运行。</li><li>Mininet提供 python APl，简单易用。</li></ul><h1 id="1-Mininet创建网络拓扑的常用的命令"><a href="#1-Mininet创建网络拓扑的常用的命令" class="headerlink" title="1.Mininet创建网络拓扑的常用的命令"></a>1.Mininet创建网络拓扑的常用的命令</h1><ul><li><p>-c       释放之前创建拓扑时占用的未释放的资源</p></li><li><p>-h       查看帮助</p></li><li><p>–topo    在mininet启动时通过命令行定义拓扑</p></li><li><p>–custom     用于创建自定义拓扑</p></li><li><p>–switch       定义要使用的交换机，默认使用OVSK交换机</p></li><li><p>–controller      定义要使用的控制器，如果没有指定则使用mininet中默认的控制器</p></li><li><p>–mac  自动设置设备的MAC地址，从而使MAC地址更易读</p></li></ul><h1 id="2-Mininet部分命令"><a href="#2-Mininet部分命令" class="headerlink" title="2.Mininet部分命令"></a>2.Mininet部分命令</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mininet&gt;</span> <span class="string">help</span>  <span class="string">获取帮助列表</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">nodes</span> <span class="string">查看网络拓扑中的节点的状态</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">links</span> <span class="string">显示链路健壮性信息</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">net</span>   <span class="string">显示网络拓扑</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">dump</span>  <span class="string">显示每个节点的接口设置和表示每个节点的进程的PID</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">pingall</span>  <span class="string">在网络中所有主机之间执行ping测试</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">pingair</span>  <span class="string">只测试前两个主机的连通性</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">iperf</span>   <span class="string">两个节点之间进行iperftcp带宽测试（iperf</span> <span class="string">h1</span> <span class="string">h2）</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">iperfudp</span> <span class="string">两个节点之间进行iperfudp带宽测试（iperfudp</span> <span class="string">bw</span> <span class="string">h1</span> <span class="string">h2）</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">link</span> <span class="string">禁用或启用节点间链路（link</span> <span class="string">s1</span> <span class="string">s2</span> <span class="string">up</span> <span class="string">启用s1和s2之间的链路</span> <span class="string">link</span> <span class="string">s1</span> <span class="string">s2</span> <span class="string">down</span> <span class="string">禁用s1和s2之间的链路）</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">h1</span> <span class="string">ping</span> <span class="string">h2</span>   <span class="string">h1和h2节点之间执行ping测试</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">h1</span> <span class="string">ifconfig</span>  <span class="string">查看host1的IP等信息</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">xterm</span> <span class="string">h1</span> <span class="string">打开host1的终端</span></span><br><span class="line"><span class="string">mininet&gt;</span> <span class="string">exit</span> <span class="string">退出mininet登录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3-常用命令用法举例"><a href="#3-常用命令用法举例" class="headerlink" title="3.常用命令用法举例"></a>3.常用命令用法举例</h1><p>（1）<code>--confroller</code></p><p><code>sudo mn --controller=remote, --ip=[controller IP], --port=[port]</code></p><p>其中ip指的是远程控制器的IP，port指的是监听端口。IP和port可忽略不写，不写默认使用本机IP和6633或6653端口。</p><p>（2）<code>--mac</code></p><p>自动设置设备的MAC地址，从而使MAC地址更易读。</p><p>设置交换机的MAC、主机MAC及IP地址从小到大排列，在拓扑比较复杂的情况容易识别机器ID。如果不设置，默认下主机随机分配MAC地址，且每次执行mn，MAC都会改变，有些调试比较困难。</p><p><strong>用例</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cd</span> <span class="string">ryu</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">ryu</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">app</span></span><br><span class="line"></span><br><span class="line"><span class="string">ls</span></span><br><span class="line"></span><br><span class="line"><span class="string">sz@ubuntu16:~/ryu/ryu/app$</span> <span class="string">sudo</span> <span class="string">ryu-manager</span> <span class="string">simple_switch.py</span>  <span class="comment">#运行这个脚本</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cd</span> <span class="string">mininet</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">mininet</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">examples</span> </span><br><span class="line"></span><br><span class="line"><span class="string">ls</span></span><br><span class="line"></span><br><span class="line"><span class="string">sz@ubuntu16:~/mininet/mininet/examples$</span> <span class="string">sudo</span> <span class="string">python</span> <span class="number">2.</span><span class="string">py</span>  </span><br><span class="line"><span class="comment">#执行2.py这个脚本</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Ryu运行界面：</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414012145685.png" alt="image-20230414012145685"></p><p><code>Mininet运行界面：</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414012305506.png" alt="image-20230414012305506"></p><p><code>输入pingall查看所有主机的连通性</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414013009824.png" alt="image-20230414013009824"></p><p>这里应该是我之前建立的网络拓扑有问题，都不通，哈哈哈哈~~</p><p>应该是链路被down了。</p><p><code>输入net 显示网络拓扑</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414013240555.png" alt="image-20230414013240555"></p><p><code>输入links 显示链路健壮性信息</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414013441946.png" alt="image-20230414013441946"></p><p><code>输入dump  显示每个节点的接口设置和表示每个节点的进程的PID</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414013741454.png" alt="image-20230414013741454"></p><p><code>输入iperf h1 h2，对h1和h2进行网络的带宽测试</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414014009357.png" alt="image-20230414014009357"></p><p>这里出错了，应该是没有连通。</p><p>下面是示例跑的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414014319914.png" alt="image-20230414014319914"></p><h1 id="4-Mininet创建网络拓扑的三种方式"><a href="#4-Mininet创建网络拓扑的三种方式" class="headerlink" title="4.Mininet创建网络拓扑的三种方式"></a>4.Mininet创建网络拓扑的三种方式</h1><h2 id="4-1-通过交互界面（命令行）创建"><a href="#4-1-通过交互界面（命令行）创建" class="headerlink" title="4.1 通过交互界面（命令行）创建"></a>4.1 通过交互界面（命令行）创建</h2><p><code>（1）单一（single）拓扑</code></p><p>整个网络拓扑中有且只有一个交换机，交换机可下挂一个或多个主机</p><p>举例：</p><p><code>sudo mn --topo=single,3 表示创建了一台交换机，交换机下挂3台主机</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414015339334.png" alt="image-20230414015339334"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414014923187.png" alt="image-20230414014923187"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414015027907.png" alt="image-20230414015027907"></p><p><code>（2）线性（linear）拓扑</code></p><p>交换机连接呈线性排列，且每个交换机所连接主机数目只有一个（交换机与主机数相同）</p><p><code>举例：sudo mn --topo=linear,3</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414015306962.png" alt="image-20230414015306962"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414015847088.png" alt="image-20230414015847088"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414015930627.png" alt="image-20230414015930627"></p><p><code>（3）树形（tree）拓扑</code></p><blockquote><p>交换机连接呈树形排列，且每个交换机下挂的主机一般有多个，类似于数据结构的二叉树。其中，depth指的是交换机的深度，depth&#x3D;2表示交换机有两层，fanout表示广度&#x2F;扇出，fanout&#x3D;3表示每台交换机均下挂3台设备。</p></blockquote><p><code>举例： sudo mn --topo=tree,depth=2,fanout=3</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414020332093.png" alt="image-20230414020332093"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414020447433.png" alt="image-20230414020447433"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414020630017.png" alt="image-20230414020630017"></p><p><code>（4）自定义（custom）拓扑</code></p><blockquote><p>可以直接执行编写好的Python脚本创建拓扑。</p><p>举例：</p><p>py net.addSwitch(‘s3’) 添加交换机s3</p><p>py net.addHost(‘h3’)   添加主机h3</p><p>py net.addLink(s1,net.get(‘h3’)) 添加s1和s3之间的链接</p><p>py s1.attach(‘s1-eth3’)  s1上添加eth3接口（端口）</p><p>py net.get(‘h3’).cmd(‘ifconfig h3-eth0 10.3’)  给h3配置ip地址为10.0.0.3</p></blockquote><h2 id="4-2-通过可视化界面创建"><a href="#4-2-通过可视化界面创建" class="headerlink" title="4.2 通过可视化界面创建"></a>4.2 通过可视化界面创建</h2><blockquote><p>首先打开miniedit</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414021558487.png" alt="image-20230414021558487"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414021826334.png" alt="image-20230414021826334"></p><p>先画一个简单的网络拓扑。</p><p>然后点击左上角的Edit,选择Preferences。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414022057491.png" alt="image-20230414022057491"></p><p>默认交换机选这个。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414022138027.png" alt="image-20230414022138027"></p><p>openflow的版本可以选1.0和1.3</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414022315317.png" alt="image-20230414022315317"></p><p>点击OK。</p><p><code>然后是设备的配置</code></p><blockquote><p>鼠标右键选中控制器，选择Properties,Name控制器的名字，Controller Port监听端口，Controller Type选择Remote Controller也就是远程控制器，如果你的控制器是安装在虚拟机上的话，它默认的是本机地址也就是127.0.0.1点击ok。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414022541267.png" alt="image-20230414022541267"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414022819717.png" alt="image-20230414022819717"></p><blockquote><p>交换机的设置也是类似的。</p><p>Hostname交换机的名字。DPID指的是在 Mininet 中，DPID 指的是数据通路 ID（Datapath ID）。它是 OpenFlow 协议中用于识别交换机的唯一标识符。每个 OpenFlow 交换机都有一个唯一的 DPID，它是一个 64 位的整数。</p><p>这里可以设置s1的DPID为000000000000001</p><p>S2的DPID为000000000000002</p><p>Switch Type选择内核模式，Open vSwitch Knernel Mode。</p><p>其他的可以不勾选。</p></blockquote><p>在 Mininet 中，可以通过在构建拓扑时使用 <code>dpid</code> 参数来指定交换机的 DPID。例如，在 Python 脚本中创建一个包含两个交换机的拓扑，可以使用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mininet.topo <span class="keyword">import</span> Topo</span><br><span class="line"><span class="keyword">from</span> mininet.net <span class="keyword">import</span> Mininet</span><br><span class="line"><span class="keyword">from</span> mininet.node <span class="keyword">import</span> OVSSwitch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTopo</span>(<span class="title class_ inherited__">Topo</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Topo.__init__(self)</span><br><span class="line"></span><br><span class="line">        s1 = self.addSwitch(<span class="string">&#x27;s1&#x27;</span>, dpid=<span class="string">&#x27;0000000000000001&#x27;</span>)</span><br><span class="line">        s2 = self.addSwitch(<span class="string">&#x27;s2&#x27;</span>, dpid=<span class="string">&#x27;0000000000000002&#x27;</span>)</span><br><span class="line">        self.addLink(s1, s2)</span><br><span class="line"></span><br><span class="line">net = Mininet(topo=MyTopo(), switch=OVSSwitch)</span><br><span class="line">net.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，使用 <code>dpid</code> 参数为交换机指定了 DPID。使用 <code>0000000000000001</code> 和 <code>0000000000000002</code> 作为示例 DPID，您可以根据需要替换它们。</p><p>需要注意的是，如果没有为交换机指定 DPID，则 Mininet 会生成一个随机的 DPID。在编写 OpenFlow 控制器代码时，需要使用正确的 DPID 来识别 Mininet 中的交换机。</p><blockquote><p>最后是主机的配置，IP Address需要和Miniedit的IP base的网段对应起来，h1的IP Address设置为10.0.0.1，h2 10.0.0.2 , h3 10.0.0.3</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414024001804.png" alt="image-20230414024001804"></p><p>这样网络拓扑就设置完了。</p><p>回到执行mininet的终端，可以看到我们在miniedit执行的所有设置在mininet都有反馈。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414024209408.png" alt="image-20230414024209408"></p><p>我们再运行这个网络拓扑，在运行网络拓扑之前我们需要先开启Ryu,也就是控制器。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414024532788.png" alt="image-20230414024532788"></p><p><code>sudo ryu-manager simple_switch.py</code> 选这个执行</p><p>然后在MiniEdit中点击左下角的run。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414024627681.png" alt="image-20230414024627681"></p><p>可以看到在Ryu已经检测到了这个网络拓扑，在Mininet中可以看到创建了网络拓扑。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414024720904.png" alt="image-20230414024720904"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414024847582.png" alt="image-20230414024847582"></p><p>下面测试一下网络的连通性等。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414024949664.png" alt="image-20230414024949664"></p><p>发现没有问题，接下来我们把这个网络拓扑保存成python文件方便以后随时使用。</p><p>首先点击stop，将运行停止。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414025117021.png" alt="image-20230414025117021"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414025158103.png" alt="image-20230414025158103"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414025311434.png" alt="image-20230414025311434"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414025521242.png" alt="image-20230414025521242"></p><p>看到文件已经保存了。</p><p>我们可以运行这个文件，看结果是否相同。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414025839487.png" alt="image-20230414025839487"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414025909906.png" alt="image-20230414025909906"></p><h2 id="4-3-如何编写python脚本创建网络拓扑"><a href="#4-3-如何编写python脚本创建网络拓扑" class="headerlink" title="4.3 如何编写python脚本创建网络拓扑"></a>4.3 如何编写python脚本创建网络拓扑</h2><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414030206357.png" alt="image-20230414030206357"></p><p>先修改文件权限，然后编辑3.py文件。</p><p>比如增加一台主机h4与s2交换机进行连接。</p><p>仿照修改即可。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414030508428.png" alt="image-20230414030508428"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414030552836.png" alt="image-20230414030552836"></p><p>保存退出即可。</p><p>执行文件查看效果。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414030735915.png" alt="image-20230414030735915"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230414030832971.png" alt="image-20230414030832971"></p>]]></content>
      
      
      <categories>
          
          <category> SDN实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDN实验搭建-安装（Mininet+Ryu）</title>
      <link href="/article/a0290e22.html"/>
      <url>/article/a0290e22.html</url>
      
        <content type="html"><![CDATA[<p><strong>SDN实验搭建-安装（Mininet+Ryu）</strong></p><h1 id="一、安装git"><a href="#一、安装git" class="headerlink" title="一、安装git"></a>一、安装git</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root//这步忽略吧，尽量别进root模式</span><br><span class="line"></span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413002711167.png" alt="image-20230413002711167"></p><h1 id="二、Mininet的安装"><a href="#二、Mininet的安装" class="headerlink" title="二、Mininet的安装"></a>二、Mininet的安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mininet/mininet.git</span><br><span class="line"></span><br><span class="line">cd mininet</span><br><span class="line"></span><br><span class="line">ls //查看目录</span><br><span class="line"></span><br><span class="line">cd util</span><br><span class="line"></span><br><span class="line">./install.sh -n3v //这步会有警告，忽略吧</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413004011607.png" alt="image-20230413004011607"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413004125985.png" alt="image-20230413004125985"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413013757728.png" alt="image-20230413013757728"></p><p>注意mn命令要在root账户或者sudo权限下。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413013946900.png" alt="image-20230413013946900"></p><p>输入pingall 来检查网络的连通性。</p><p>在安装RYU之前，需要安装pip。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line"></span><br><span class="line">python get-pip.py  //最低版本python3.7,安装python3.8的教程在下面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413014424613.png" alt="image-20230413014424613"></p><p>安装Python 3.8 可以按照以下步骤在 Ubuntu 16.04 上进行：</p><ol><li><p>确认系统已经安装了必要的依赖库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install build-essential checkinstall</span><br><span class="line"></span><br><span class="line">sudo apt-get install libreadline-gplv2-dev libncursesw5-dev libssl-dev \</span><br><span class="line">libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev libffi-dev zlib1g-dev</span><br></pre></td></tr></table></figure></li><li><p>下载 Python 3.8 的源代码包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line"></span><br><span class="line">sudo wget  https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tgz</span><br></pre></td></tr></table></figure></li><li><p>解压源代码包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar xzf Python-3.8.0.tgz</span><br></pre></td></tr></table></figure></li><li><p>编译源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.8.0</span><br><span class="line"></span><br><span class="line">sudo ./configure --enable-optimizations</span><br><span class="line"></span><br><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure><p>这里使用 <code>make altinstall</code> 命令安装 Python 3.8 而不是 <code>make install</code> 命令，是为了避免破坏系统自带的 Python 2.7。</p></li><li><p>安装完成后，可以使用以下命令来验证 Python 3.8 是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.8 --version</span><br></pre></td></tr></table></figure><p>如果显示 Python 3.8.x 的版本号，则说明安装成功。</p><p>直接<code>python3.8 get-pip.py</code></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413014739839.png" alt="image-20230413014739839"></p><h1 id="三、安装RYU"><a href="#三、安装RYU" class="headerlink" title="三、安装RYU"></a>三、安装RYU</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/osrg/ryu.git</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413022321411.png" alt="image-20230413022321411"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ryu</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">pip install -r tools/pip-requires  //安装之前，先安装所需要的依赖</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413022623674.png" alt="image-20230413022623674"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413022659637.png" alt="image-20230413022659637"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install //安装ryu 出错的话，用python3.8</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413023446793.png" alt="image-20230413023446793"></p><p>验证RYU是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd ryu</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">cd app</span><br><span class="line"></span><br><span class="line">ryu-manager example_switch_13.py //先别回车，另一个终端先提前输好命令  </span><br><span class="line"></span><br><span class="line">mn --controller=remote //另一个终端敲的命令，使用远端控制器，这个命令在后面。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413024025036.png" alt="image-20230413024025036"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413024039692.png" alt="image-20230413024039692"></p><p>输入<code>pingall</code></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413024325990.png" alt="image-20230413024325990"></p><p>如何启动mininet的可视化界面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd mininet</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">cd examples</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">./miniedit.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230413024550577.png" alt="image-20230413024550577"></p>]]></content>
      
      
      <categories>
          
          <category> SDN实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDN实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建图床</title>
      <link href="/article/87689537.html"/>
      <url>/article/87689537.html</url>
      
        <content type="html"><![CDATA[<p>注：本文转载于<a href="https://zhuanlan.zhihu.com/p/489236769%E3%80%82">https://zhuanlan.zhihu.com/p/489236769。</a></p><h2 id="1-注册一个Github账号"><a href="#1-注册一个Github账号" class="headerlink" title="1. 注册一个Github账号"></a><strong>1. 注册一个Github账号</strong></h2><p>首先你需要一个github账号，如果没有的话，先注册。</p><p>github官网地址： <a href="https://link.zhihu.com/?target=https://github.com/">https://github.com/</a></p><p>注册过程省略，因为这是保姆都不管的事情。</p><p>友情提示：可能在注册过程中会出现 “Unable to verify your captcha response… …”，一直不能正常注册。</p><p>网上有各种解决方案：换浏览器、换电脑… …</p><h2 id="2-配置Github"><a href="#2-配置Github" class="headerlink" title="2. 配置Github"></a>2. 配置Github</h2><h3 id="2-1-创建一个新仓库，用于存放图片。"><a href="#2-1-创建一个新仓库，用于存放图片。" class="headerlink" title="2.1 创建一个新仓库，用于存放图片。"></a>2.1 创建一个新仓库，用于存放图片。</h3><p><img src="https://pic1.zhimg.com/80/v2-59b7f87b4fbe21a2492e4b9e529fe87c_720w.webp" alt="img"></p><p>填写仓库名称和描述，且仓库必须是public的，否则存储的图片不能正常访问。</p><p><img src="https://pic3.zhimg.com/80/v2-d3733c14e8c9b53cb5cf9f7607d51c8a_720w.webp" alt="img"></p><h3 id="2-2-生成一个token，用于picGo访问github"><a href="#2-2-生成一个token，用于picGo访问github" class="headerlink" title="2.2 生成一个token，用于picGo访问github"></a>2.2 生成一个token，用于picGo访问github</h3><p><img src="https://pic4.zhimg.com/80/v2-4d227062bcfa58dba6c0582c982b737b_720w.webp" alt="img"></p><p>选择左侧菜单的Developer settings</p><p><img src="https://pic4.zhimg.com/80/v2-4d227062bcfa58dba6c0582c982b737b_720w.webp" alt="img"></p><p>之后选择左侧Personal access tokens，再点击Generate new token</p><p><img src="https://pic1.zhimg.com/80/v2-2d5bcabac97557591c4203009d306750_720w.webp" alt="img"></p><p>填写Note，勾选repo.</p><p><img src="https://pic2.zhimg.com/80/v2-346da4ccf189eb5997abe2fadadca331_720w.webp" alt="img"></p><p>注意，生成的token只会在这里显示一次，所以记得单独保存下来哦。</p><p><img src="https://pic3.zhimg.com/80/v2-354ea85a4bd9cfc99157b86cae9a2332_720w.webp" alt="img"></p><p>至此，Github的配置完成。</p><h2 id="3-下载picGo，并进行配置"><a href="#3-下载picGo，并进行配置" class="headerlink" title="3. 下载picGo，并进行配置"></a>3. 下载picGo，并进行配置</h2><h3 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1 下载"></a>3.1 下载</h3><p>网络不好的情况下，PicGo下载可能会多次失败，所以我把下载好的应用放在百度网盘了。</p><p>大家按需取用。</p><p><img src="https://pic4.zhimg.com/80/v2-279f576c0dc0861fd7edcf1d43e5675f_720w.webp" alt="img"></p><p>网盘地址：<a href="https://link.zhihu.com/?target=https://pan.baidu.com/s/1LvkzLJyZcjpflK2Evq3X9A">https://pan.baidu.com/s/1LvkzLJyZcjpflK2Evq3X9A</a> 提取码：s6x7</p><p>下载完成，双击启动安装即可。</p><p>如果安装成功，picGo不能正常使用，则可以用兼容模式启动。【此问题因电脑而异，也是我在配置过程中踩过的坑。】</p><p><img src="https://pic2.zhimg.com/80/v2-3f60ccb549e01c95a1702ceca9bda95d_720w.webp" alt="img"></p><h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h3><p>仓库名：[github用户名]&#x2F;[第一步新建的仓库名称]</p><p>分支：默认master，从2020.10.01开始，github的默认分支名变更为main</p><p>设定token：第一步创建的token</p><p>指定存储路径：可填可不填，如果填写了，图片就会存储在img文件夹下</p><p>设定自定义域名：<a href="https://cdn.jsdelivr.net/gh/[github%E7%94%A8%E6%88%B7%E5%90%8D]/[%E4%BB%93%E5%BA%93%E5%90%8D]@main%EF%BC%8C%E6%B3%A8%E6%84%8F%EF%BC%8C%E6%AD%A4%E5%A4%84%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%80%E5%AE%9A%E8%A6%81%E5%A1%AB%E5%86%99@main%EF%BC%8C%E5%90%A6%E5%88%99%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8master%E5%88%86%E6%94%AF%E3%80%82%E8%80%8C%E7%8E%B0%E5%9C%A8github%E5%88%9B%E5%BB%BA%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF%E5%90%8D%E4%B8%BAmain%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%8C%87%E5%AE%9A%EF%BC%8C%E5%88%99%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E8%83%BD%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%E3%80%90%E8%B8%A9%E5%9D%91%E4%B8%A4%E5%B0%8F%E6%97%B6%E3%80%91">https://cdn.jsdelivr.net/gh/[github用户名]/[仓库名]@main，注意，此处的分支一定要填写@main，否则默认使用master分支。而现在github创建的默认分支名为main，如果不指定，则会出现图片不能上传的情况。【踩坑两小时】</a></p><p><img src="https://pic3.zhimg.com/80/v2-62e4faaa7999d1d32fa80aec44b4034e_720w.webp" alt="img"></p><p>至此，github+picGo的配置完成，可以在上传区进行图片上传了。</p><h3 id="3-3-补充几点"><a href="#3-3-补充几点" class="headerlink" title="3.3 补充几点"></a>3.3 补充几点</h3><p>1.原本github的自定义域名应该是：[<a href="https://raw.githubusercontent.com/[username/]/[%E4%BB%93%E5%BA%93%E5%90%8D]](https://link.zhihu.com/?target=https://raw.githubusercontent.com/%5Busername%5D/%5B%E4%BB%93%E5%BA%93%E5%90%8D%5D)">https://raw.githubusercontent.com/[username\]/[仓库名]](https://link.zhihu.com/?target=https%3A//raw.githubusercontent.com/%5Busername%5D/%5B%E4%BB%93%E5%BA%93%E5%90%8D%5D)</a></p><p>但是使用这种方式访问图片巨慢，所以教程中使用了jsdelivr作为cdn加速。改变域名即可，不需要任何其他配置。</p><p>2.配置完成，可能出现不能上传的情况，请大家耐心检查，也许某一步的配置出现了问题，就像检查bug一样耐心、细心。想象一下图床搭建成功后，写起文章来的丝滑感，是不是又有动力了？</p><h2 id="4-PicGo集成Typora"><a href="#4-PicGo集成Typora" class="headerlink" title="4. PicGo集成Typora"></a>4. PicGo集成Typora</h2><p>使用MarkDown语法写文章，我使用的编辑器是typora，一款超级好用的编辑器。在一个编辑框内，编辑完成后，可以马上显示MarkDown语法效果。</p><p>举个栗子：</p><p><img src="https://pic2.zhimg.com/80/v2-ce0b207c19d6ca32ac22937f1dc6cfcd_720w.webp" alt="img"></p><p>并且typora可以和picGo联合在一起使用，当你在编辑器中插入、粘贴图片时，typora+picGo的组合方式，可以自动把图片上传至github保存。</p><h3 id="4-1-下载安装"><a href="#4-1-下载安装" class="headerlink" title="4.1 下载安装"></a>4.1 下载安装</h3><p>Typora新版本是收费的，所以建议大家使用旧版本就可以了，完全能满足写作需求。</p><p>旧版本安装包和picGo放在一起了（下载地址见上文），大家按需取用即可。</p><p>下载完成后正常步骤安装即可。</p><h3 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h3><p>在typora顶部菜单界面，选择“文件” - &gt; “偏好设置”，设置图片存储方式。</p><p><img src="https://pic1.zhimg.com/80/v2-f595cf5c8a0e3b62944c68deb8fb5878_720w.webp" alt="img"></p><p>选择图片存储方式：上传图片。</p><p>上传服务：PicGo(app)</p><p>PicGo路径：picGo安装的地址</p><p>设置完成，点击“验证图片上传”，提示上传成功，即代表配置成功。</p><p><img src="https://pic2.zhimg.com/80/v2-e27e9f198aef7bdea365549b2257025d_720w.webp" alt="img"></p><p>注意一点，typora图片验证中的端口，需要与picGo中的server设置内的端口一致，否则typora中不能正常上传。</p><h3 id="4-3-picGo监听端口设置"><a href="#4-3-picGo监听端口设置" class="headerlink" title="4.3 picGo监听端口设置"></a>4.3 picGo监听端口设置</h3><p>选择“PicGo设置”–&gt;“设置server”</p><p><img src="https://pic4.zhimg.com/80/v2-8ff622935a6b0597a21e68e7575e16ef_720w.webp" alt="img"></p><p>【此处有坑】如果监听端口不是36677，则需要修改为36677。否则会出现picGo能正常上传 图片，而typora上传图片失败的情况。</p><p><img src="https://pic3.zhimg.com/80/v2-304589efaed9a1ba3caf5e8827e77582_720w.webp" alt="img"></p><p>最后，在苹果电脑中可以使用<strong>Typora+Ipic+Github</strong>的方式，有兴趣的话可以自行尝试</p><p><strong>总结：github+picGo+typora他们三个是好基友。</strong></p><p>分享到此结束，保姆也该撤了~</p>]]></content>
      
      
      <categories>
          
          <category> 网站优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算实验7-Spark基本操作</title>
      <link href="/article/d52e23ed.html"/>
      <url>/article/d52e23ed.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spark简介"><a href="#Spark简介" class="headerlink" title="Spark简介"></a>Spark简介</h1><p><strong>Apache Spark</strong>是一个<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90">开源</a>集群运算框架，最初是由加州大学柏克莱分校AMPLab所开发。相对于<a href="https://zh.wikipedia.org/wiki/Apache_Hadoop">Hadoop</a>的<a href="https://zh.wikipedia.org/wiki/MapReduce">MapReduce</a>会在运行完工作后将中介数据存放到磁盘中，Spark使用了存储器内运算技术，能在数据尚未写入硬盘时即在存储器内分析运算。Spark在存储器内运行程序的运算速度能做到比Hadoop MapReduce的运算速度快上100倍，即便是运行程序于硬盘时，Spark也能快上10倍速度。Spark允许用户将数据加载至集群存储器，并多次对其进行查询，非常适合用于<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a>算法。</p><p>使用Spark需要搭配集群管理员和分布式存储系统。Spark支持独立模式（本地Spark集群）、<a href="https://zh.wikipedia.org/wiki/Apache_Hadoop">Hadoop YARN</a>或<a href="https://zh.wikipedia.org/wiki/Apache_Mesos">Apache Mesos</a>的集群管理。在分布式存储方面，Spark可以和<a href="https://zh.wikipedia.org/wiki/Apache_Hadoop">HDFS</a>、 <a href="https://zh.wikipedia.org/wiki/Apache_Cassandra">Cassandra</a>、<a href="https://zh.wikipedia.org/wiki/OpenStack#Object_Storage_(Swift)">OpenStack Swift</a>和<a href="https://zh.wikipedia.org/wiki/Amazon_S3">Amazon S3</a>等接口搭载。 Spark也支持伪分布式（pseudo-distributed）本地模式，不过通常只用于开发或测试时以本机文件系统取代分布式存储系统。在这样的情况下，Spark仅在一台机器上使用每个CPU核心运行程序。</p><h1 id="项目构成要素"><a href="#项目构成要素" class="headerlink" title="项目构成要素"></a>项目构成要素</h1><p>Spark项目包含下列几项:</p><ol><li>Spark核心和弹性分布式数据集（RDDs） Spark核心是整个项目的基础，提供了分布式任务调度，调度和基本的I&#x2F;O功能。而其基础的程序抽象则称为弹性分布式数据集（RDDs），是一个可以并行操作、有容错机制的数据集合。 RDDs可以透过引用外部存储系统的数据集创建（例如：共享文件系统、HDFS、HBase或其他 Hadoop 数据格式的数据源）。或者是透过在现有RDDs的转换而创建（比如：map、filter、reduce、join等等）。 RDD抽象化是经由一个以<a href="https://zh.wikipedia.org/wiki/Scala">Scala</a>, <a href="https://zh.wikipedia.org/wiki/Java">Java</a>, <a href="https://zh.wikipedia.org/wiki/Python">Python</a>的语言集成API所呈现，简化了编程复杂性，应用程序操纵RDDs的方法类似于操纵本地端的数据集合。</li><li>Spark SQL Spark SQL在Spark核心上带出一种名为SchemaRDD的数据抽象化概念，提供结构化和半结构化数据相关的支持。Spark SQL提供了领域特定语言，可使用Scala、Java或Python来操纵SchemaRDDs。它还支持使用使用命令行界面和ODBC／JDBC服务器操作SQL语言。在Spark 1.3版本，SchemaRDD被重命名为DataFrame。</li><li>Spark Streaming Spark Streaming充分利用Spark核心的快速调度能力来运行流分析。它截取小批量的数据并对之运行RDD转换。这种设计使流分析可在同一个引擎内使用同一组为批量分析编写而撰写的应用程序代码。</li><li>MLlib MLlib是Spark上分布式机器学习框架。Spark分布式存储器式的架构比Hadoop磁盘式的<a href="https://zh.wikipedia.org/w/index.php?title=Apache_Mahout&action=edit&redlink=1">Apache Mahout</a>快上10倍，扩展性甚至比<a href="https://zh.wikipedia.org/w/index.php?title=Vowpal_Wabbit&action=edit&redlink=1">Vowpal Wabbit</a>要好。MLlib可使用许多常见的机器学习和统计算法，简化大规模机器学习时间。</li><li>GraphX GraphX是Spark上的分布式图形处理框架。它提供了一组API，可用于表达图表计算并可以模拟Pregel抽象化。GraphX还对这种抽象化提供了优化运行。 GraphX最初为<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%B8%E6%9F%8F%E5%85%8B%E8%90%8A%E5%88%86%E6%A0%A1">加州大学柏克莱分校</a>AMPLab和Databricks的研究项目，后来捐赠给Spark项目。</li></ol><h1 id="实验1-用Spark计算PI的值"><a href="#实验1-用Spark计算PI的值" class="headerlink" title="实验1. 用Spark计算PI的值"></a>实验1. 用Spark计算PI的值</h1><p>Spark附带了几个示例程序。 Scala，Java，Python和R示例位于examples&#x2F;src&#x2F;main目录中。 要运行其中一个Java或Scala示例程序，请在顶级Spark目录中使用bin&#x2F;run-example <class> <a href="http://gitcourse.kfcoding.com/">params</a>。下面介绍使用Spark计算PI的值。</p><p>进入Spark根目录，执行以下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /opt/spark/dist</span><br><span class="line"># ./bin/run-example SparkPi 10</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171636876.png" alt="image-20230401171636876">迭代10次以后得到PI的近似值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pi is roughly 3.1393791393791393</span><br></pre></td></tr></table></figure><p>Spark同时提供了Python版本的示例程序，通过以下命令执行PI计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ./bin/spark-submit /opt/spark/dist/examples/src/main/python/pi.py</span><br></pre></td></tr></table></figure><p>近似结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pi is roughly 3.140280</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171651175.png" alt="image-20230401171651175"></p><h1 id="实验2-在spark-shell中执行词频统计"><a href="#实验2-在spark-shell中执行词频统计" class="headerlink" title="实验2. 在spark-shell中执行词频统计"></a>实验2. 在spark-shell中执行词频统计</h1><h2 id="2-1-编辑输入文件"><a href="#2-1-编辑输入文件" class="headerlink" title="2.1 编辑输入文件"></a>2.1 编辑输入文件</h2><p>本次实验统计某个文件中单词出现的次数，首先编辑输入文件。实训环境中已经提供了输入文件，路径为&#x2F;root&#x2F;input.txt，读者可根据需要自行编辑。文件的内容为：</p><p>hello world hello spark hello hadoop</p><h1 id="实验2-在spark-shell中执行词频统计-1"><a href="#实验2-在spark-shell中执行词频统计-1" class="headerlink" title="实验2. 在spark-shell中执行词频统计"></a>实验2. 在spark-shell中执行词频统计</h1><h2 id="2-2-启动spark-shell"><a href="#2-2-启动spark-shell" class="headerlink" title="2.2 启动spark-shell"></a>2.2 启动spark-shell</h2><p>执行以下命令启动spark-shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /opt/spark/dist</span><br><span class="line"># ./bin/spark-shell</span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171705228.png" alt="image-20230401171705228"></p><h1 id="实验2-在spark-shell中执行词频统计-2"><a href="#实验2-在spark-shell中执行词频统计-2" class="headerlink" title="实验2. 在spark-shell中执行词频统计"></a>实验2. 在spark-shell中执行词频统计</h1><h2 id="2-4-词频统计"><a href="#2-4-词频统计" class="headerlink" title="2.4 词频统计"></a>2.4 词频统计</h2><p>完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val textFile = sc.textFile(&quot;file:///root/input.txt&quot;)</span><br><span class="line">scala&gt; val wordCount = textFile.flatMap(line =&gt; line.split(&quot; &quot;)).map(word =&gt; (word, 1)).reduceByKey((a, b) =&gt; a + b)</span><br><span class="line">scala&gt; wordCount.collect()</span><br></pre></td></tr></table></figure><p>上面只给出了代码，省略了执行过程中返回的结果信息，因为返回信息很多。下面简单解释一下上面的语句。</p><p>textFile包含了多行文本内容，textFile.flatMap(line &#x3D;&gt; line.split(” “))会遍历textFile中的每行文本内容，当遍历到其中一行文本内容时，会把文本内容赋值给变量line，并执行Lamda表达式line &#x3D;&gt; line.split(” “)。line &#x3D;&gt; line.split(” “)是一个Lamda表达式，左边表示输入参数，右边表示函数里面执行的处理逻辑，这里执行line.split(” “)，也就是针对line中的一行文本内容，采用空格作为分隔符进行单词切分，从一行文本切分得到很多个单词构成的单词集合。这样，对于textFile中的每行文本，都会使用Lamda表达式得到一个单词集合，最终，多行文本，就得到多个单词集合。textFile.flatMap()操作就把这多个单词集合“拍扁”得到一个大的单词集合。</p><p>然后，针对这个大的单词集合，执行map()操作，也就是map(word &#x3D;&gt; (word, 1))，这个map操作会遍历这个集合中的每个单词，当遍历到其中一个单词时，就把当前这个单词赋值给变量word，并执行Lamda表达式word &#x3D;&gt; (word, 1)，这个Lamda表达式的含义是，word作为函数的输入参数，然后，执行函数处理逻辑，这里会执行(word, 1)，也就是针对输入的word，构建得到一个tuple，形式为(word,1)，key是word，value是1（表示该单词出现1次）。</p><p>程序执行到这里，已经得到一个RDD，这个RDD的每个元素是(key,value)形式的tuple。最后，针对这个RDD，执行reduceByKey((a, b) &#x3D;&gt; a + b)操作，这个操作会把所有RDD元素按照key进行分组，然后使用给定的函数（这里就是Lamda表达式：(a, b) &#x3D;&gt; a + b），对具有相同的key的多个value进行reduce操作，返回reduce后的(key,value)，比如(“hello”,1)和(“hello”,1)，具有相同的key，进行reduce以后就得到(“hello”,2)，这样就计算得到了这个单词的词频。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171727279.png" alt="image-20230401171727279"></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算实验6-Kubernetes基本操作</title>
      <link href="/article/efb270a7.html"/>
      <url>/article/efb270a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes简介"><a href="#Kubernetes简介" class="headerlink" title="Kubernetes简介"></a>Kubernetes简介</h1><p>Kubernetes 是 Google 团队发起的开源项目，它的目标是管理跨多个主机的容器，提供基本的部署，维护以及运用伸缩，主要实现语言为Go语言。Kubernetes 特性有：</p><ul><li>易学：轻量级，简单，容易理解</li><li>便携：支持公有云，私有云，混合云，以及多种云平台</li><li>可拓展：模块化，可插拔，支持钩子，可任意组合</li><li>自修复：自动重调度，自动重启，自动复制</li></ul><p>Kubernetes 构建于 Google 数十年经验，一大半来源于 Google 生产环境规模的经验。结合了社区最佳的想法和实践。在分布式系统中，部署，调度，伸缩一直是最为重要的也最为基础的功能。Kubernets 就是希望解决这一序列问题的。Kubernets 目前在GitHub进行维护。</p><p>目前，Kubenetes 支持在多种环境下的安装，包括本地主机（Fedora）、云服务（Google GAE、AWS 等）。然而最快速体验 Kubernetes 的方式显然是本地通过 Docker 的方式来启动相关进程。</p><p>下图展示了在单节点使用 Docker 快速部署一套 Kubernetes 的拓扑。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171302899.png" alt="image-20230401171302899">                                </p><h2 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h2><p>Minikube是一种工具，可以在本地轻松运行Kubernetes。 Minikube在笔记本电脑的VM中运行单节点Kubernetes集群，供那些希望尝试Kubernetes或者日常开发的用户使用，本节实验将基于Minikube来完成。</p><p>Minikube支持以下特性：</p><ul><li>DNS</li><li>NodePorts</li><li>ConfigMaps     and Secrets</li><li>Dashboards</li><li>Container     Runtime: Docker, rkt, CRI-O and containerd</li><li>Enabling     CNI (Container Network Interface)</li><li>Ingress</li></ul><h1 id="实验1-Minikube基本操作"><a href="#实验1-Minikube基本操作" class="headerlink" title="实验1. Minikube基本操作"></a>实验1. Minikube基本操作</h1><h2 id="1-1-启动-Minikube"><a href="#1-1-启动-Minikube" class="headerlink" title="1.1. 启动 Minikube"></a>1.1. 启动 Minikube</h2><p>执行以下命令启动docker及minikube</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># start.sh</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171309822.png" alt="image-20230401171309822"></p><h2 id="1-2-查看集群状态"><a href="#1-2-查看集群状态" class="headerlink" title="1.2. 查看集群状态"></a>1.2. 查看集群状态</h2><p>可以使用kubectl CLI与集群进行交互。这是用于管理Kubernetes和在群集上运行的应用程序的主要方法。</p><p>可以通过以下方式发现群集及其运行状况的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># kubectl cluster-info</span><br><span class="line"> </span><br><span class="line">Kubernetes master is running at https://127.0.0.1:8443</span><br><span class="line">To further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;.</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171323911.png" alt="image-20230401171323911"></p><h2 id="1-3-查看集群节点"><a href="#1-3-查看集群节点" class="headerlink" title="1.3. 查看集群节点"></a>1.3. 查看集群节点</h2><p>使用 kubectl get nodes 列出节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get nodes</span><br><span class="line">NAME           STATUS    ROLES     AGE       VERSION</span><br><span class="line">30b561aec9a2   Ready     &lt;none&gt;    52s       v1.8.0</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171331231.png" alt="image-20230401171331231"></p><p>如果节点标记为NotReady，则它仍在启动组件。此命令显示可用于托管应用程序的所有节点。现在我们只有一个节点，我们可以看到它的状态已准备好（它已准备好接受部署的应用程序）。</p><h1 id="实验2-通过-kubectl-部署容器"><a href="#实验2-通过-kubectl-部署容器" class="headerlink" title="实验2. 通过 kubectl 部署容器"></a>实验2. 通过 kubectl 部署容器</h1><p>其群启动完成以后，可以使用 kubectl 进行部署容器操作</p><h2 id="2-1-启动容器"><a href="#2-1-启动容器" class="headerlink" title="2.1 启动容器"></a>2.1 启动容器</h2><p>执行以下命令启动一个nginx服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kubectl run first-deployment --image=nginx:alpine --port=80</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171336641.png" alt="image-20230401171336641"></p><h2 id="2-2-查看Pod状态"><a href="#2-2-查看Pod状态" class="headerlink" title="2.2 查看Pod状态"></a>2.2 查看Pod状态</h2><p>可以通过以下方式查看Pod状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get pod</span><br><span class="line"> </span><br><span class="line">NAME                                READY     STATUS    RESTARTS   AGE</span><br><span class="line">first-deployment-84d55ddb97-pt6ws   1/1       Running   0          12s</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171355912.png" alt="image-20230401171355912"></p><p>当pod状态为 Running 时，说明 pod 启动完成，容器正在运行</p><h2 id="2-3-暴漏服务端口"><a href="#2-3-暴漏服务端口" class="headerlink" title="2.3 暴漏服务端口"></a>2.3 暴漏服务端口</h2><p>容器运行后，可以根据需要通过不同的网络选项进行暴露。 一种可能的解决方案是NodePort，它为容器提供动态端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kubectl expose deployment first-deployment --port=80 --type=NodePort</span><br></pre></td></tr></table></figure><p>如果节点标记为NotReady，则它仍在启动组件。此命令显示可用于托管应用程序的所有节点。现在我们只有一个节点，我们可以看到它的状态已准备好（它已准备好接受部署的应用程序）。</p><h2 id="2-4-查找已分配的端口并执行HTTP请求"><a href="#2-4-查找已分配的端口并执行HTTP请求" class="headerlink" title="2.4 查找已分配的端口并执行HTTP请求"></a>2.4 查找已分配的端口并执行HTTP请求</h2><p>以下命令查找已分配的端口并执行HTTP请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># export PORT=$(kubectl get svc first-deployment -o go-template=&#x27;&#123;&#123;range.spec.ports&#125;&#125;&#123;&#123;if .nodePort&#125;&#125;&#123;&#123;.nodePort&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;)</span><br><span class="line"># echo &quot;$PORT&quot;</span><br><span class="line"># curl localhost:$PORT</span><br><span class="line"> </span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171407329.png" alt="image-20230401171407329"></p><h2 id="2-5-删除-nginx服务"><a href="#2-5-删除-nginx服务" class="headerlink" title="2.5 删除 nginx服务"></a>2.5 删除 nginx服务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kubectl delete deploy/first-deployment</span><br><span class="line">deployment &quot;first-deployment&quot; deleted</span><br></pre></td></tr></table></figure><h1 id="实验3-通过YAML文件部署容器"><a href="#实验3-通过YAML文件部署容器" class="headerlink" title="实验3. 通过YAML文件部署容器"></a>实验3. 通过YAML文件部署容器</h1><p>除了使用 kubectl 直接部署容器以外，还可以通过 YAML文件的方式部署容器。</p><h2 id="3-1-创建-Deployment"><a href="#3-1-创建-Deployment" class="headerlink" title="3.1 创建 Deployment"></a>3.1 创建 Deployment</h2><p>最常见的Kubernetes对象之一是deployment对象。deployment对象定义了所需的容器规范，以及Kubernetes的其他部分用于发现和连接到应用程序的名称和标签。</p><p>查看 nginx-deployment.yaml 文件。该定义实现了基于nginx:alpine镜像启动容器，并开放容器的80端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># cat /k8s/nginx-deployment.yaml</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: webapp1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: webapp1</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: webapp1</span><br><span class="line">        image: nginx:alpine</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>使用以下命令部署 nginx-deployment.yaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /k8s</span><br><span class="line"># kubectl create -f nginx-deployment.yaml</span><br><span class="line">deployment &quot;webapp1&quot; created</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171420463.png" alt="image-20230401171420463"></p><p>查看deployment状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get deployment</span><br><span class="line">NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">webapp1   1         1         1            1           7s</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171427721.png" alt="image-20230401171427721"></p><p>查看详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># kubectl describe deployment webapp1</span><br><span class="line">Name:                   webapp1</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Fri, 03 May 2019 14:07:14 +0000</span><br><span class="line">Labels:                 app=webapp1</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision=1</span><br><span class="line">Selector:               app=webapp1</span><br><span class="line">Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  1 max unavailable, 1 max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=webapp1</span><br><span class="line">  Containers:</span><br><span class="line">   webapp1:</span><br><span class="line">    Image:        katacoda/docker-http-server:latest</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   webapp1-65d887cc9f (1/1 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  56s   deployment-controller  Scaled up replica set webapp1-65d887cc9f to 1</span><br></pre></td></tr></table></figure><h2 id="3-2-创建-Service"><a href="#3-2-创建-Service" class="headerlink" title="3.2 创建 Service"></a>3.2 创建 Service</h2><p>Kubernetes具有强大的网络功能，可控制应用程序的通信方式。 这些网络配置也可以通过YAML进行控制。</p><p>查看 nginx-service.yaml。该service将主机的30080端口映射到容器的80端口，服务选择标签为webapp1的所有应用程序。在部署多个副本或实例时，它们将根据此公共标签自动进行负载均衡。该服务通过NodePort提供应用服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># cat /k8s/nginx-service.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: webapp1-svc</span><br><span class="line">  labels:</span><br><span class="line">    app: webapp1</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    nodePort: 30080</span><br><span class="line">  selector:</span><br><span class="line">    app: webapp1</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171440826.png" alt="image-20230401171440826"></p><p>通过 kubectl 部署 service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># kubectl apply -f nginx-service.yaml</span><br><span class="line">service &quot;webapp1-svc&quot; created</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171446764.png" alt="image-20230401171446764"></p><p>查看 service 状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get service</span><br><span class="line">NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">first-deployment   NodePort    10.99.229.208   &lt;none&gt;        80:30826/TCP   1m</span><br><span class="line">kubernetes         ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        3m</span><br><span class="line">webapp1-svc        NodePort    10.110.18.126   &lt;none&gt;        80:30080/TCP   4s</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171458546.png" alt="image-20230401171458546"></p><p>查看 service 详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># kubectl describe svc webapp1-svc</span><br><span class="line">Name:                     webapp1-svc</span><br><span class="line">Namespace:                default</span><br><span class="line">Labels:                   app=webapp1</span><br><span class="line">Annotations:              kubectl.kubernetes.io/last-applied-configuration=&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;labels&quot;:&#123;&quot;app&quot;:&quot;webapp1&quot;&#125;,&quot;name&quot;:&quot;webapp1-svc&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;ports&quot;...</span><br><span class="line">Selector:                 app=webapp1</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP:                       10.110.5.113</span><br><span class="line">Port:                     &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:               80/TCP</span><br><span class="line">NodePort:                 &lt;unset&gt;  30080/TCP</span><br><span class="line">Endpoints:                172.18.0.4:80</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171506850.png" alt="image-20230401171506850"></p><h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl localhost:30080</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171510862.png" alt="image-20230401171510862"></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算实验5-Mininet基本操作</title>
      <link href="/article/b4f16210.html"/>
      <url>/article/b4f16210.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mininet简介"><a href="#Mininet简介" class="headerlink" title="Mininet简介"></a>Mininet简介</h1><p>Mininet是由一些虚拟的终端节点（end-hosts）、交换机、路由器连接而成的一个网络仿真器，它采用轻量级的虚拟化技术使得系统可以和真实网络相媲美。</p><p>Mininet可以很方便地创建一个支持SDN的网络：host就像真实的电脑一样工作，可以使用ssh登录，启动应用程序，程序可以向以太网端口发送数据包，数据包会被交换机、路由器接收并处理。有了这个网络，就可以灵活地为网络添加新的功能并进行相关测试，然后轻松部署到真实的硬件环境中。</p><p>Mininet的特性</p><ul><li>可以简单、迅速地创建一个支持用户自定义的网络拓扑，缩短开发测试周期</li><li>可以运行真实的程序，在Linux上运行的程序基本上可以都可以在Mininet上运行，如Wireshark</li><li>Mininet支持Openflow，在Mininet上运行的代码可以轻松移植到支持OpenFlow的硬件设备上</li><li>Mininet可以在自己的电脑，或服务器，或虚拟机，或者云（例如Amazon EC2）上运行</li><li>Mininet提供python API，简单易用</li><li>Mininet是开源项目，源代码在这里：<a href="https://github.com/mininet">https://github.com/mininet</a></li></ul><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><p>学习使用mininet基本命令</p><p>mininet命令参数分为三大类：</p><ul><li>用于创建网络拓扑结构的命令参数；</li><li>用于查看现有(或创建好的)网络拓扑中的各个节点(设备)的网络状态（ip地址、连通性等信息）；</li><li>用于修改当前网络拓扑，对已有的设备进行增删改查操作。</li></ul><h1 id="实验1-查看现有网络拓扑中的节点网络状态的命令参数"><a href="#实验1-查看现有网络拓扑中的节点网络状态的命令参数" class="headerlink" title="实验1. 查看现有网络拓扑中的节点网络状态的命令参数"></a>实验1. 查看现有网络拓扑中的节点网络状态的命令参数</h1><h2 id="1-0-启动-openvswitch"><a href="#1-0-启动-openvswitch" class="headerlink" title="1.0 启动 openvswitch"></a>1.0 启动 openvswitch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service openvswitch-switch start</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170709496.png" alt="image-20230401170709496"></p><h2 id="1-1-net"><a href="#1-1-net" class="headerlink" title="1.1 net"></a>1.1 net</h2><p>查看链路信息，两个设备之间的之间连线，称为一个链路，链路是双向的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mn</span><br><span class="line">mininet&gt; net</span><br><span class="line">h1 h1-eth0:s1-eth1</span><br><span class="line">h2 h2-eth0:s1-eth2</span><br><span class="line">s1 lo:  s1-eth1:h1-eth0 s1-eth2:h2-eth0</span><br><span class="line">c0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170720554.png" alt="image-20230401170720554"></p><h2 id="1-2-nodes"><a href="#1-2-nodes" class="headerlink" title="1.2 nodes"></a>1.2 nodes</h2><p>查看有哪些可用节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; nodes</span><br><span class="line">available nodes are: </span><br><span class="line">c0 h1 h2 s1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170728707.png" alt="image-20230401170728707"></p><h2 id="1-3-links"><a href="#1-3-links" class="headerlink" title="1.3 links"></a>1.3 links</h2><p>检测链路是否正常工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; links</span><br><span class="line">h1-eth0&lt;-&gt;s1-eth1 (OK OK)</span><br><span class="line">h2-eth0&lt;-&gt;s1-eth2 (OK OK)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170736067.png" alt="image-20230401170736067"></p><h2 id="1-4-pingall"><a href="#1-4-pingall" class="headerlink" title="1.4 pingall"></a>1.4 pingall</h2><p>检测各个主机之间的连通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; pingall</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170743338.png" alt="image-20230401170743338"></p><h2 id="1-5-pingpair"><a href="#1-5-pingpair" class="headerlink" title="1.5 pingpair"></a>1.5 pingpair</h2><p>检测前两个主机的连通性      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; pingpair</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170751061.png" alt="image-20230401170751061"></p><h2 id="1-6-dump"><a href="#1-6-dump" class="headerlink" title="1.6 dump"></a>1.6 dump</h2><p>查看节点信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; dump</span><br><span class="line">&lt;Host h1: h1-eth0:10.0.0.1 pid=524&gt; </span><br><span class="line">&lt;Host h2: h2-eth0:10.0.0.2 pid=526&gt; </span><br><span class="line">&lt;OVSSwitch s1: lo:127.0.0.1,s1-eth1:None,s1-eth2:None pid=531&gt; </span><br><span class="line">&lt;Controller c0: 127.0.0.1:6633 pid=516&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170801729.png" alt="image-20230401170801729"></p><h2 id="1-7-exit"><a href="#1-7-exit" class="headerlink" title="1.7 exit"></a>1.7 exit</h2><p>退出mininet命令模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; exit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170808153.png" alt="image-20230401170808153"></p><h1 id="实验2-创建网络拓扑结构的命令参数"><a href="#实验2-创建网络拓扑结构的命令参数" class="headerlink" title="实验2. 创建网络拓扑结构的命令参数"></a>实验2. 创建网络拓扑结构的命令参数</h1><h2 id="1-–topo"><a href="#1-–topo" class="headerlink" title="1 –topo"></a>1 –topo</h2><p>可以创建具有一定规则的网络拓扑结构，也可以创建自定义的网络拓扑结构。</p><h3 id="1-1-single-topo："><a href="#1-1-single-topo：" class="headerlink" title="1.1 single topo："></a>1.1 single topo：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mn --topo=single,3</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170815984.png" alt="image-20230401170815984"></p><p>表示创建单个交换机3个主机的拓扑网络结构，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170825192.png" alt="image-20230401170825192"></p><p>links用于查看链路连通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; links</span><br><span class="line">h1-eth0&lt;-&gt;s1-eth1 (OK OK)</span><br><span class="line">h2-eth0&lt;-&gt;s1-eth2 (OK OK)</span><br><span class="line">h3-eth0&lt;-&gt;s1-eth3 (OK OK)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170836896.png" alt="image-20230401170836896"></p><p>dump查看节点信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; dump</span><br><span class="line">&lt;Host h1: h1-eth0:10.0.0.1 pid=410&gt; </span><br><span class="line">&lt;Host h2: h2-eth0:10.0.0.2 pid=412&gt; </span><br><span class="line">&lt;Host h3: h3-eth0:10.0.0.3 pid=414&gt; </span><br><span class="line">&lt;OVSSwitch s1: lo:127.0.0.1,s1-eth1:None,s1-eth2:None,s1-eth3:None pid=419&gt; </span><br><span class="line">&lt;Controller c0: 127.0.0.1:6633 pid=402&gt; </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170851765.png" alt="image-20230401170851765"></p><p>exit 退出 mininet 命令模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; exit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/clip_image025.jpg" alt="img"></p><h3 id="1-2-linear-topo"><a href="#1-2-linear-topo" class="headerlink" title="1.2 linear topo"></a>1.2 linear topo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mn --topo=linear,5</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170916218.png" alt="image-20230401170916218"></p><p>表示创建一个如下图所示的网络拓扑：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170931880.png" alt="image-20230401170931880"></p><p>links用于查看链路连通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; links</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170942540.png" alt="image-20230401170942540"></p><p>dump查看节点信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; dump</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/clip_image033.jpg" alt="img"></p><p>exit 退出 mininet 命令模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; exit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/clip_image035.jpg" alt="img"></p><h3 id="1-3-tree-topo"><a href="#1-3-tree-topo" class="headerlink" title="1.3 tree topo"></a>1.3 tree topo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mn --topo=tree,depth=2,fanout=3</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171000025.png" alt="image-20230401171000025"></p><p>表示创建了一个如下图所示的网络拓扑：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/clip_image039.png" alt="图片包含 形状  描述已自动生成"></p><p>links用于查看链路连通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; links</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171011716.png" alt="image-20230401171011716"></p><p>dump查看节点信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; dump</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171022715.png" alt="image-20230401171022715"></p><p>exit 退出 mininet 命令模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; exit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/clip_image045.jpg" alt="img"></p><h2 id="2-–switch"><a href="#2-–switch" class="headerlink" title="2. –switch"></a>2. –switch</h2><p>定义网络拓扑要使用的交换机。</p><p>后面可以接的参数有：ovsk、ovsbr、ivs、lxbr、user，前面三种均为OVS型交换机，后面两种分别为内核型(linux bridge)和用户型(user)交换机。</p><p>交换机分类3类：用户型、内核型和OVS型，其中内核型和OVS型的吞吐量比用户性大很多，因此一般采用后两种。可以测试三者的TCP bandwidth(区别UDP bandwidth):</p><p>内核型吞吐量测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mn --test iperf</span><br><span class="line">部分输出结果如下：</span><br><span class="line">*** Iperf: testing TCP bandwidth between h1 and h2</span><br><span class="line">*** Results: [&#x27;20.4 Gbits/sec&#x27;, &#x27;20.4 Gbits/sec&#x27;]</span><br><span class="line">*** Stopping 1 controllers</span><br><span class="line">completed in 10.558 seconds</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/clip_image047.jpg" alt="img"></p><p>OVS型吞吐量测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mn --switch ovsk --test iperf</span><br><span class="line">部分输出结果如下：</span><br><span class="line">*** Iperf: testing TCP bandwidth between h1 and h2</span><br><span class="line">*** Results: [&#x27;24.7 Gbits/sec&#x27;, &#x27;24.8 Gbits/sec&#x27;]</span><br><span class="line">*** Stopping 1 controllers</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/clip_image049.jpg" alt="img"></p><h2 id="3-–mac"><a href="#3-–mac" class="headerlink" title="3. –mac"></a>3. –mac</h2><p>使用这个参数可以让MAC地址从小到达排列，使得复杂的网络更清晰，容易辨识各个组件的MAC地址。不使用这个参数的话，复杂的网络容易混乱。</p><h1 id="实验3-修改当前网络拓扑的命令参数"><a href="#实验3-修改当前网络拓扑的命令参数" class="headerlink" title="实验3. 修改当前网络拓扑的命令参数"></a>实验3. 修改当前网络拓扑的命令参数</h1><h2 id="1-link"><a href="#1-link" class="headerlink" title="1. link"></a>1. link</h2><p>禁用&#x2F;开启两个节点之间的链路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mn</span><br><span class="line">mininet&gt; link h2 s1 down</span><br><span class="line">mininet&gt; link h2 s1 up</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/clip_image051.jpg" alt="img"></p><h2 id="2-iperf"><a href="#2-iperf" class="headerlink" title="2. iperf"></a>2. iperf</h2><p>测试两个主机之间的TCP带宽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; iperf</span><br><span class="line">*** Iperf: testing TCP bandwidth between h1 and h2</span><br><span class="line">*** Results: [&#x27;22.1 Gbits/sec&#x27;, &#x27;22.1 Gbits/sec&#x27;]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171058961.png" alt="image-20230401171058961"></p><h2 id="3-iperfudp"><a href="#3-iperfudp" class="headerlink" title="3. iperfudp"></a>3. iperfudp</h2><p>测试两个主机之间的UDP带宽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; iperfudp</span><br><span class="line">*** Iperf: testing UDP bandwidth between h1 and h2</span><br><span class="line">*** Results: [&#x27;10M&#x27;, &#x27;10.0 Mbits/sec&#x27;, &#x27;10.0 Mbits/sec&#x27;]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401171115259.png" alt="image-20230401171115259"></p><h2 id="4-dpctl"><a href="#4-dpctl" class="headerlink" title="4. dpctl"></a>4. dpctl</h2><p>对所有交换机操作流表，包括流表的显示、添加、修改、删除，具体用法，参考</p><h2 id="5-xterm"><a href="#5-xterm" class="headerlink" title="5. xterm"></a>5. xterm</h2><p>如xterm h1打开主机h1的操作窗口</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算实验4-Ceph基本操作</title>
      <link href="/article/3d1222c6.html"/>
      <url>/article/3d1222c6.html</url>
      
        <content type="html"><![CDATA[<p><strong>ceph 简介</strong></p><p>Ceph是一个可靠地、自动重均衡、自动恢复的分布式存储系统，根据场景划分可以将Ceph分为三大块，分别是对象存储、块设备存储和文件系统服务。在虚拟化领域里，比较常用到的是Ceph的块设备存储，比如在OpenStack项目里，Ceph的块设备存储可以对接OpenStack的cinder后端存储、Glance的镜像存储和虚拟机的数据存储，比较直观的是Ceph集群可以提供一个raw格式的块存储来作为虚拟机实例的硬盘。</p><p>Ceph相比其它存储的优势点在于它不单单是存储，同时还充分利用了存储节点上的计算能力，在存储每一个数据时，都会通过计算得出该数据存储的位置，尽量将数据分布均衡，同时由于Ceph的良好设计，采用了CRUSH算法、HASH环等方法，使得它不存在传统的单点故障的问题，且随着规模的扩大性能并不会受到影响。</p><p>最底层的RADOS提供了对象存储的功能，是ceph的根基所在。所有的其他功能都是在RADOS之上构建的。LIBRADOS看名字就能猜到，它提供了一系列语言的接口，可以直接访问RADOS。RADOSGW基于LIBRADOS实现了REST的接口并兼容S3和Swift。RBD也基于LIBRADOS提供了块存储。最后是CEPH FS直接基于RADOS实现了文件存储系统。</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170358520.png" alt="image-20230401170358520"></p><h1 id="实验1-基于docker的ceph基本操作实验"><a href="#实验1-基于docker的ceph基本操作实验" class="headerlink" title="实验1. 基于docker的ceph基本操作实验"></a>实验1. 基于docker的ceph基本操作实验</h1><h2 id="1-启动ceph测试环境"><a href="#1-启动ceph测试环境" class="headerlink" title="1. 启动ceph测试环境"></a>1. 启动ceph测试环境</h2><p>启动docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service docker start</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170410733.png" alt="image-20230401170410733"></p><p>导入镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker load &lt; /root/ceph.tar</span><br><span class="line"># docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID </span><br><span class="line">ceph/demo           latest              ed38ba053588</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170419660.png" alt="image-20230401170419660"></p><p>查看IP地址及网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig</span><br></pre></td></tr></table></figure><p>这里假设IP地址为 172.17.0.2，网络为 172.17.0.0&#x2F;16</p><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170441485.png" alt="image-20230401170441485"></p><p>启动 ceph测试环境（IP地址和网络需要替换为实际的值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d --net=host -v /etc/ceph:/etc/ceph -e MON_IP=172.17.0.2 -e CEPH_PUBLIC_NETWORK=172.17.0.0/16 ceph/demo</span><br></pre></td></tr></table></figure><h2 id="2-cephfs挂载"><a href="#2-cephfs挂载" class="headerlink" title="2. cephfs挂载"></a>2. cephfs挂载</h2><p>首先查看 key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/ceph/ceph.client.admin.keyring</span><br><span class="line">AQBni81cnAC9GRAAzY2I9Wz+5gMdcY4ceGBcyA==(以实际输出为准)</span><br></pre></td></tr></table></figure><p>挂载cephfs（IP地址和secret替换为上面实际输出的内容）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t ceph -o name=admin,secret=AQBni81cnAC9GRAAzY2I9Wz+5gMdcY4ceGBcyA== 172.17.0.2:/ /mnt/cephfs</span><br></pre></td></tr></table></figure><p>查看挂载结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170455147.png" alt="image-20230401170455147"></p><h2 id="3-rbd方式"><a href="#3-rbd方式" class="headerlink" title="3. rbd方式"></a>3. rbd方式</h2><p>还有一种方式是作为rbd来加载。rbd的模型：最外层是pool，相当于一块磁盘，默认的pool名字叫做rbd。每个pool里面可以有多个image，相当于文件夹。每个image可以映射成一个块设备，有了设备就可以加载它。</p><p>首先创建一个名为 test_pool 的 pool ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd pool create test_pool 128</span><br></pre></td></tr></table></figure><p>128代表placement-group的数量。每个pg都是一个虚拟节点，将自己的数据存在不同的位置。这样一旦存储出现问题，pg就会选择新的存储，从而保证了自动高可用。运行这个命令就可以看到现在系统中的所有pool：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ceph osd lspools</span><br></pre></td></tr></table></figure><p>然后在 test_pool 这个pool里创建一个名为 test_image 的image：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rbd create test_pool/test_image --size 128</span><br></pre></td></tr></table></figure><p>size的单位是MB，所以这个 test_image image的大小为128M。运行下列命令可以看到 test_pool 的pool中的所有 test_image 和查看 test_image 的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># rbd ls test_pool</span><br><span class="line"># rbd info test_pool/test_image</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401170510553.png" alt="image-20230401170510553"></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算实验3-Docker基本操作</title>
      <link href="/article/515fbdc.html"/>
      <url>/article/515fbdc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><p>Docker 是一个开源的应用容器引擎，基于 Go 语言并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。</p><p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p><h1 id="实验1-Docker镜像基本操作"><a href="#实验1-Docker镜像基本操作" class="headerlink" title="实验1 Docker镜像基本操作"></a>实验1 Docker镜像基本操作</h1><p>本次实验包含docker基本操作，本次实验仅提供简单docker操作命令演示，更多操作请访问<a href="https://docs.docker.com/">官方文档</a></p><h2 id="1-1-实验之前可能需要手动启动-docker-服务"><a href="#1-1-实验之前可能需要手动启动-docker-服务" class="headerlink" title="1.1 实验之前可能需要手动启动 docker 服务"></a>1.1 实验之前可能需要手动启动 docker 服务</h2><p>若docker可正常使用，则无需进行该1.1步骤所对应的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># kill掉docker僵死进程</span><br><span class="line"># netstat -ntulp|grep 2376|awk &#x27;&#123;printf $7&#125;&#x27;|cut -d/ -f1 | xargs kill -9</span><br><span class="line"> </span><br><span class="line"># 手动启动docker服务</span><br><span class="line"># /usr/local/bin/dockerd-entrypoint.sh &amp;</span><br></pre></td></tr></table></figure><p>待出现API listen on <a href="http://gitcourse.kfcoding.com/">::</a>:2376提示后，按下回车键，即可正常使用docker服务</p><p>此外，使用clear命令可以实现清屏功能～</p><h2 id="1-2-查看本机所有的镜像"><a href="#1-2-查看本机所有的镜像" class="headerlink" title="1.2 查看本机所有的镜像"></a>1.2 查看本机所有的镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker images</span><br></pre></td></tr></table></figure><p>实验环境中没有镜像，所以只输出头信息</p><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162257585.png" alt="image-20230401162257585"></p><h2 id="1-3-查找镜像"><a href="#1-3-查找镜像" class="headerlink" title="1.3 查找镜像"></a>1.3 查找镜像</h2><p>通过 docker search 命令查找镜像，如查找 alpine 镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker search alpine</span><br></pre></td></tr></table></figure><p>部分输出结果如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">alpine                                 A minimal Docker image based on Alpine Linux…   <span class="number">5237</span>                [OK]                </span><br><span class="line">mhart/alpine-node                      Minimal Node.js built on Alpine Linux           <span class="number">428</span>                                     </span><br><span class="line">anapsix/alpine-java                    Oracle Java <span class="number">8</span> (and <span class="number">7</span>) with GLIBC <span class="number">2.28</span> over A…   <span class="number">406</span>                                     [OK]</span><br><span class="line">frolvlad/alpine-glibc                  Alpine Docker image with glibc (~<span class="number">12</span>MB)          <span class="number">201</span>                                     [OK]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162406483.png" alt="image-20230401162406483"></p><h2 id="1-4-拉取镜像"><a href="#1-4-拉取镜像" class="headerlink" title="1.4 拉取镜像"></a>1.4 拉取镜像</h2><p>查找到需要的镜像以后，可以通过 docker pull 命令拉取指定的镜像，以拉取 alpine 镜像为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker pull alpine</span><br><span class="line"># docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">alpine              latest              cdf98d1859c1        3 weeks ago         5.53MB</span><br></pre></td></tr></table></figure><p>如果不指定镜像标签，则默认拉取latest版本的镜像</p><p>输出：<img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162423580.png" alt="image-20230401162423580"></p><h2 id="1-5-构建镜像"><a href="#1-5-构建镜像" class="headerlink" title="1.5 构建镜像"></a>1.5 构建镜像</h2><p>当搜索不到需要的镜像时，可以使用 docker build 命令构建镜像，我们以 alpine:latest 为基础镜像，添加自定义脚本，并在容器启动时执行脚本，输出 “hello docker”</p><p>首先使用vi命令构建需要的文件，文件内容输入结束后使用:wq!保存文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># vi /home/test.sh</span><br><span class="line">echo &quot;hello docker&quot;</span><br><span class="line"> </span><br><span class="line"># vi /home/Dockerfile</span><br><span class="line">FROM alpine:latest</span><br><span class="line">ADD ./test.sh /test.sh</span><br><span class="line">RUN chmod +x /test.sh</span><br><span class="line">CMD [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;/test.sh&quot;]</span><br></pre></td></tr></table></figure><p>查看test.sh文件，该脚本仅输出”hello docker”到终端，不执行其它操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd /home</span><br><span class="line"># cat test.sh</span><br><span class="line">echo &quot;hello docker&quot;</span><br></pre></td></tr></table></figure><p>查看 Dockerfile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat Dockerfile</span><br><span class="line">FROM alpine:latest</span><br><span class="line">ADD ./test.sh /test.sh</span><br><span class="line">RUN chmod +x /test.sh</span><br><span class="line">CMD [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;/test.sh&quot;]</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162447593.png" alt="image-20230401162447593"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162455130.png" alt="image-20230401162455130"></p><p>构建镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker build -t hello-docker .</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162509100.png" alt="image-20230401162509100"></p><p>运行构建的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run --name hello-docker hello-docker</span><br><span class="line">hello-docker</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162525662.png" alt="image-20230401162525662"></p><p>可以看到容器正确执行了自定义到脚本</p><h2 id="1-6-删除镜像"><a href="#1-6-删除镜像" class="headerlink" title="1.6 删除镜像"></a>1.6 删除镜像</h2><p>使用 docker rmi <ID> 命令可以删除一个镜像</p><h1 id="实验2-容器基本操作"><a href="#实验2-容器基本操作" class="headerlink" title="实验2 容器基本操作"></a>实验2 容器基本操作</h1><p>本次实验包含docker基本操作，本次实验仅提供简单docker操作命令演示，更多操作请访问<a href="https://docs.docker.com/">官方文档</a></p><h2 id="2-1-查看本机所有容器"><a href="#2-1-查看本机所有容器" class="headerlink" title="2.1 查看本机所有容器"></a>2.1 查看本机所有容器</h2><p>使用 docker ps 命令可以查看本机正在运行的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker ps</span><br></pre></td></tr></table></figure><p>当前没有正在运行的容器，所以只输出头信息</p><p>输出：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162542940.png" alt="image-20230401162542940"></p><p>使用 docker ps -a 命令可以查看所有的(包括停止的)容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                 CREATED              STATUS                          PORTS               NAMES</span><br><span class="line">67c35fbd2030        hello-docker        &quot;/bin/sh -c /test.sh&quot;   About a minute ago   Exited (0) About a minute ago                       hello-docker</span><br></pre></td></tr></table></figure><p>可以看到上一节实验中运行过的 hello-docker 容器</p><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162600076.png" alt="image-20230401162600076"></p><h2 id="2-2-创建容器"><a href="#2-2-创建容器" class="headerlink" title="2.2 创建容器"></a>2.2 创建容器</h2><p>使用 docker create 命令可以创建新的容器，例如基于hello-docker镜像创建一个名为my-container的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker create --name my-container hello-docker:latest</span><br><span class="line">177f676188754f2fe48ffa2ac18a499f25c00708fa43d8f4253092802025d0a3</span><br></pre></td></tr></table></figure><p>创建完成后，会输出新创建的容器的ID，注意，此时只是创建了容器，并没有运行容器。</p><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162613428.png" alt="image-20230401162613428"></p><h2 id="2-3-启动容器"><a href="#2-3-启动容器" class="headerlink" title="2.3 启动容器"></a>2.3 启动容器</h2><p>创建完容器以后，可以通过 docker start 命令启动容器，例如启动上面创建的 my-container 容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker start -i my-container</span><br></pre></td></tr></table></figure><p>ID需要填入读者自己创建容器时输出的ID，启动容器以后默认不输出信息到控制台，因此，需要加 -i 参数将输出信息重定向到控制台。</p><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162626825.png" alt="image-20230401162626825"></p><h2 id="2-4-查看容器信息"><a href="#2-4-查看容器信息" class="headerlink" title="2.4 查看容器信息"></a>2.4 查看容器信息</h2><p>使用 docker inspect &lt;ID|Name&gt; 命令查看容器信息，例如查看上面创建的 my-container 容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker inspect my-container</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162638405.png" alt="image-20230401162638405"></p><h2 id="2-5-直接运行容器"><a href="#2-5-直接运行容器" class="headerlink" title="2.5 直接运行容器"></a>2.5 直接运行容器</h2><p>可以通过先创建后运行的方式运行一个容器，也可以通过 docker run 命令直接运行一个容器，如运行一个 hello-docker 容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run hello-docker</span><br><span class="line">hello-docker</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162652259.png" alt="image-20230401162652259"></p><h2 id="2-6-后台运行容器"><a href="#2-6-后台运行容器" class="headerlink" title="2.6 后台运行容器"></a>2.6 后台运行容器</h2><p>hello-docker 容器只输出一句 “hello docker” 便退出了，而像 mysql、nginx 这些容器需要一直保持后台运行状态，此时，我们可以使用 -d 参数让容器在后台运行，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d --hostname nginx --name nginx nginx:alpine</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162707010.png" alt="image-20230401162707010"></p><p>测试容器运行情况：</p><p>首先查看容器的IP地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker inspect nginx</span><br></pre></td></tr></table></figure><p>部分输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;Networks&quot;: &#123;</span><br><span class="line">    &quot;bridge&quot;: &#123;</span><br><span class="line">        &quot;IPAMConfig&quot;: null,</span><br><span class="line">        &quot;Links&quot;: null,</span><br><span class="line">        &quot;Aliases&quot;: null,</span><br><span class="line">        &quot;NetworkID&quot;: &quot;b62a412ff73bfcae29ee9c7fe7460b07c41ebab138907270b0066a2785e5cedf&quot;,</span><br><span class="line">        &quot;EndpointID&quot;: &quot;02347c1c388825d2b28c18eb892c745229c07c58f3d4a46135c879977a359cf1&quot;,</span><br><span class="line">        &quot;Gateway&quot;: &quot;172.18.0.1&quot;,</span><br><span class="line">        &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,</span><br><span class="line">        &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">        &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">        &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">        &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">        &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">        &quot;DriverOpts&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IP地址为 172.18.0.2（以实际输出为准）</p><p>实际输出：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162730217.png" alt="image-20230401162730217"></p><p>请求 nginx 首页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl 172.18.0.2 (IP地址以实际输出信息为准)</span><br></pre></td></tr></table></figure><p>输出内容如下：(因基础镜像的原因，curl工具在当前实训环境中不可用，同学们可参考以下输出)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以看到容器在后台运行，并且正确请求到了nginx首页信息</p><h2 id="2-7-进入容器-shell-环境"><a href="#2-7-进入容器-shell-环境" class="headerlink" title="2.7 进入容器 shell 环境"></a>2.7 进入容器 shell 环境</h2><p>使用 docker exec 命令可以与容器进行交互，例如与 nginx 容器进行交互</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker exec -it nginx sh</span><br></pre></td></tr></table></figure><p>此时进入容器的 shell 环境，使用exit命令可以退出容器 shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># exit</span><br></pre></td></tr></table></figure><h2 id="2-8-查看容器运行日志"><a href="#2-8-查看容器运行日志" class="headerlink" title="2.8 查看容器运行日志"></a>2.8 查看容器运行日志</h2><p>使用 docker logs &lt;ID|Name&gt; 查看容器运行日志，例如查看nginx容器运行日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker logs nginx</span><br><span class="line">172.18.0.1 - - [03/May/2019:07:21:31 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.47.0&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162753836.png" alt="image-20230401162753836"></p><h2 id="2-9-停止容器"><a href="#2-9-停止容器" class="headerlink" title="2.9 停止容器"></a>2.9 停止容器</h2><p>使用 docker stop &lt;ID|Name&gt; 停止容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker stop nginx</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>nginx容器已经停止</p><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162807364.png" alt="image-20230401162807364"></p><h2 id="2-10-删除容器"><a href="#2-10-删除容器" class="headerlink" title="2.10 删除容器"></a>2.10 删除容器</h2><p>使用 docker rm &lt;ID|Name&gt;命令可以删除容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rm nginx</span><br></pre></td></tr></table></figure><p>如果nginx容器正在运行，则会提示删除错误，需要先停止nginx容器再删除，或者添加 -f 参数强制删除</p><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162818841.png" alt="image-20230401162818841"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker rm -f nginx</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><h1 id="实验3-volume基本操作"><a href="#实验3-volume基本操作" class="headerlink" title="实验3 volume基本操作"></a>实验3 volume基本操作</h1><p>在本节课程中，你将学习如何在容器内使用 docker volumes 来持久数据。docker volumes 允许在容器和容器版本之间共享目录。</p><p>docker volumes 允许你升级容器、重启机器和共享数据，而不会造成数据丢失。在更新数据库或应用程序版本时，这是必不可少的。</p><p>当容器启动时，docker volumes 被创建和分配。数据卷允许你讲主机目录映射到容器里，以便共享数据。</p><p>这种映射是双向的。它允许存储在主机上的数据从容器中访问。它还意味着容器内进程保存的数据保存在主机上。</p><p>本次实验仅提供简单docker操作命令演示，更多操作请访问<a href="https://docs.docker.com/">官方文档</a></p><h2 id="3-1-查看本机数据卷"><a href="#3-1-查看本机数据卷" class="headerlink" title="3.1 查看本机数据卷"></a>3.1 查看本机数据卷</h2><p>使用 docker volume ls 命令查看本机的volume</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br></pre></td></tr></table></figure><p>初始状态没有volume，所以仅输出头信息</p><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162834041.png" alt="image-20230401162834041"></p><h2 id="3-1-创建volume"><a href="#3-1-创建volume" class="headerlink" title="3.1 创建volume"></a>3.1 创建volume</h2><p>使用 docker volume create <name> 创建数据卷，例如创建一个名为 nginx-v 的 volume</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker volume create nginx-v</span><br><span class="line">nginx-v</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162844127.png" alt="image-20230401162844127"></p><h2 id="3-2-查看-volume-信息"><a href="#3-2-查看-volume-信息" class="headerlink" title="3.2 查看 volume 信息"></a>3.2 查看 volume 信息</h2><p>使用 docker inspect <volume-name> 查看 volume 信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># docker inspect nginx-v</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2019-05-03T07:33:20Z&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/nginx-v/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;nginx-v&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到，nginx-v 数据卷的主机路径为 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;nginx-v&#x2F;_data</p><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162900356.png" alt="image-20230401162900356"></p><h2 id="3-3-挂载-volume"><a href="#3-3-挂载-volume" class="headerlink" title="3.3 挂载 volume"></a>3.3 挂载 volume</h2><p>在运行容器时，需要指定数据卷进行挂载，我们运行 nginx 容器，并挂载已创建的 nginx-v 数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d --name nginx-2 -v nginx-v:/var/log/nginx nginx:alpine</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162933200.png" alt="image-20230401162933200"></p><p>这条命令将 nginx-v 挂载到容器的 &#x2F;var&#x2F;log&#x2F;nginx 目录，访问本机的 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;nginx-v&#x2F;_data 目录，即相当于访问容器的 &#x2F;var&#x2F;log&#x2F;nginx 目录</p><p>首先查看本机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;nginx-v&#x2F;_data目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ls /var/lib/docker/volumes/nginx-v/_data</span><br><span class="line">access.log  error.log </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401162947235.png" alt="image-20230401162947235"></p><p>其中，access.log error.log 2个文件为容器中nginx创建的文件</p><p>在本机的 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;nginx-v&#x2F;_data 创建一个测试文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;hello volume&quot; &gt; /var/lib/docker/volumes/nginx-v/_data/test</span><br></pre></td></tr></table></figure><p>查看容器中的 &#x2F;var&#x2F;log&#x2F;nginx&#x2F;test 文件</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401163000019.png" alt="image-20230401163000019"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker exec -it nginx-2 cat /var/log/nginx/test</span><br><span class="line">hello volume</span><br></pre></td></tr></table></figure><p>可以看到输出内容即为在主机上写入的 “hello volume”</p><h2 id="3-4-直接挂载数据卷"><a href="#3-4-直接挂载数据卷" class="headerlink" title="3.4 直接挂载数据卷"></a>3.4 直接挂载数据卷</h2><p>前面通过先创建再挂载的方式使用数据卷，docker命令行支持在创建容器时直接创建数据卷</p><p>下面这条命令将主机的 &#x2F;docker 目录挂载到容器的 &#x2F;volume&#x2F;docker 目录</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -it -v /docker:/volume/docker alpine ls /volume/docker</span></span><br><span class="line">Dockerfile  test.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401163151563.png" alt="image-20230401163151563"></p><h2 id="3-4-共享volume"><a href="#3-4-共享volume" class="headerlink" title="3.4 共享volume"></a>3.4 共享volume</h2><p>映射到主机的数据卷对于持久化数据非常有用。但是，为了从另一个容器中获得它们，你需要做的确切的路径，这会使它容易出错。另一种方法是使用 -volumes-from。参数将映射的卷从源容器映射到正在启动的容器。 在这种情况下，我们将 nginx-2 容器的卷映射到一个 alpine 容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run --volumes-from nginx-2 -it alpine ls /var/log/nginx</span><br><span class="line">access.log  error.log   test</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401163203838.png" alt="image-20230401163203838"></p><p>可以看到，在新创建的alpine容器中，可以正常访问 nginx-v 数据卷的内容，实现了容器间共享数据卷</p><h2 id="3-5-删除volume"><a href="#3-5-删除volume" class="headerlink" title="3.5 删除volume"></a>3.5 删除volume</h2><p>检查是否有容器正在占用待删除Volume：</p><p>删除数据卷volume的话，需要删除对此volume进行占用的所有容器，比如使用docker volume rm <volume-name>删除数据卷的时候，可能报错，”Error response from daemon: remove nginx-v: volume is in use - <a href="http://gitcourse.kfcoding.com/">357302956d67…</a>“，使用docker ps -a命令查看所有容器，我们可以看到CONTAINER ID为357302956d67的容器(NAMES为nginx-2)，正是此容器在占用待删除volume，我们需要将此容器进行删除。</p><p>删除占用volume的容器，可以通过docker rm <NAMES> -f 或者docker rm <CONTAINER ID> -f删除容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker rm nginx-2 -f</span><br></pre></td></tr></table></figure><p>然后我们就可以通过 docker volume rm <volume-name> 可以删除一个数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker volume rm nginx-v</span><br></pre></td></tr></table></figure><p>(此时如果容器正在运行，则会提示删除数据卷失败，需要先删除容器，再删除数据卷)</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401163218183.png" alt="image-20230401163218183"></p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401163222403.png" alt="image-20230401163222403"></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算实验2-Hadoop基本操作</title>
      <link href="/article/f841b3c0.html"/>
      <url>/article/f841b3c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hadoop简介"><a href="#1-Hadoop简介" class="headerlink" title="1. Hadoop简介"></a>1. Hadoop简介</h1><h2 id="Hadoop的组件"><a href="#Hadoop的组件" class="headerlink" title="Hadoop的组件"></a>Hadoop的组件</h2><p>下图显示了 Hadoop 生态系统的各种组件。 <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image002.png" alt="图表  描述已自动生成"></p><h2 id="Apache-Hadoop-由两个子项目组成"><a href="#Apache-Hadoop-由两个子项目组成" class="headerlink" title="Apache Hadoop 由两个子项目组成"></a>Apache Hadoop 由两个子项目组成</h2><ul><li>Hadoop     MapReduce : MapReduce 是一种计算模型及软件架构，编写在Hadoop上运行的应用程序。这些MapReduce程序能够对大型集群计算节点并行处理大量的数据。</li><li>HDFS     (Hadoop Distributed File System): HDFS 处理 Hadoop 应用程序的存储部分。 MapReduce应用使用来自HDFS的数据。HDFS创建数据块的多个副本，并集群分发它们到计算节点。这种分配使得应用可靠和极其迅速的计算。</li></ul><p>虽然 Hadoop 是因为 MapReduce 和分布式文件系统 HDFS 而最出名的， 该术语也是在分布式计算和大规模数据处理的框架下的相关项目。 Apache Hadoop 的其他相关的项目包括有：Hive，HBase，Mahout，Sqoop , Flume 和 ZooKeeper。</p><h2 id="Hadoop-功能"><a href="#Hadoop-功能" class="headerlink" title="Hadoop 功能"></a>Hadoop 功能</h2><ul><li>适用于大数据分析 作为大数据在自然界中趋于分布和非结构化，Hadoop 集群最适合于大数据的分析。因为，它处理逻辑(未实际数据)流向计算节点，更少的网络带宽消耗。这个概念被称为数据区域性概念，它可以帮助提高基于 Hadoop 应用程序的效率。</li><li>可扩展性 HADOOP集群通过增加附加群集节点可以容易地扩展到任何程度，并允许大数据的增长。 另外，标度不要求修改到应用程序逻辑。</li><li>容错 HADOOP生态系统有一个规定，来复制输入数据到其他群集节点。这样一来，在集群某一节点有故障的情况下，数据处理仍然可以继续，通过使用存储另一个群集节点上的数据。</li></ul><h1 id="2-HDFS基本操作实验"><a href="#2-HDFS基本操作实验" class="headerlink" title="2. HDFS基本操作实验"></a>2. HDFS基本操作实验</h1><h2 id="2-1-启动HDFS"><a href="#2-1-启动HDFS" class="headerlink" title="2.1. 启动HDFS"></a>2.1. 启动HDFS</h2><p>进入Hadoop目录启动分布式文件系统。以下命令将启动namenode以及数据节点作为集群。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># service ssh restart</span><br><span class="line"># cd /usr/local/hadoop</span><br><span class="line"># sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401005200928.png" alt="image-20230401005200928"></p><h2 id="2-2-将数据插入HDFS"><a href="#2-2-将数据插入HDFS" class="headerlink" title="2.2. 将数据插入HDFS"></a>2.2. 将数据插入HDFS</h2><p>假设我们在本地系统中的称为file.txt的文件中有数据，应该保存在hdfs文件系统中。按照以下步骤在Hadoop文件系统中插入所需的文件。</p><ol><li>创建本地文件file.txt</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.  # touch /home/file.txt</span><br><span class="line">3.  # echo &quot;hello world&quot;  &gt;  /home/file.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401005302312.png" alt="image-20230401005302312"></p><p>2.您必须创建一个输入目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># hadoop fs -mkdir /user</span><br><span class="line"># hadoop fs -mkdir /user/input</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401005326263.png" alt="image-20230401005326263"></p><p>3.使用put命令将数据文件从本地系统传输并存储到Hadoop文件系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hadoop fs -put /home/file.txt /user/input</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401005353620.png" alt="image-20230401005353620"></p><p>4.可以使用ls命令验证文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hadoop fs -ls /user/input</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401005457489.png" alt="image-20230401005457489"></p><h2 id="2-3-从HDFS检索数据"><a href="#2-3-从HDFS检索数据" class="headerlink" title="2.3. 从HDFS检索数据"></a>2.3. 从HDFS检索数据</h2><p>现在我们在HDFS中已经有一个名为file.txt的文件。下面给出的是从Hadoop文件系统中检索所需文件的简单示例。</p><ol><li>最初，使用cat命令查看HDFS中file.txt的数据。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hadoop fs -cat /user/input/file.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401005513420.png" alt="image-20230401005513420"></p><ol start="2"><li>使用get命令将文件从HDFS获取到本地文件系统。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /home/hadoop_tp</span><br><span class="line"># hadoop fs -get /user/input/ /home/hadoop_tp/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401005523626.png" alt="image-20230401005523626"></p><ol start="3"><li>查看拉取的文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ls /home/hadoop_tp/input/</span><br><span class="line"># cat /home/hadoop_tp/input/file.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401010008034.png" alt="image-20230401010008034"></p><h2 id="2-4-删除HDFS中所有数据"><a href="#2-4-删除HDFS中所有数据" class="headerlink" title="2.4. 删除HDFS中所有数据"></a>2.4. 删除HDFS中所有数据</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hadoop fs -rm -r -f /user</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401010030315.png" alt="image-20230401010030315"></h2><h1 id="3-MapReduce基本操作实验"><a href="#3-MapReduce基本操作实验" class="headerlink" title="3. MapReduce基本操作实验"></a>3. MapReduce基本操作实验</h1><p><strong>实验目的</strong></p><p>熟悉MapReduce的架构和基本操作。查看官方给的例子，在Hadoop的伪分布式模式下，以grep为实验对象了解执行MapReduce作业的过程，了解mapper函数和reducer函数。</p><p><strong>实验原理</strong></p><p>Hadoop MapReduce是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上TB级别的数据集。</p><p>一个MapReduce作业（job）通常会把输入的数据集切分为若干独立的数据块，由map任务（task）以完全并行的方式处理它们。框架会对map的输出先进行排序， 然后把结果输入给reduce任务。通常作业的输入和输出都会被存储在 文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p><p>通常，MapReduce框架和分布式文件系统是运行在一组相同的节点上的，也就是说，计算节点和存储节点通常在一起。这种配置允许框架在那些已经存好数据的节点上高效地调度任务，这可以使整个集群的网络带宽被非常高效地利用。</p><p>MapReduce框架由一个单独的master和每个集群节点一个slave共同组成。master负责调度构成一个作业的所有任务，这些任务分布在不同的slave上，master监控它们的执行，重新执行已经失败的任务。而slave仅负责执行由master指派的任务。</p><p><strong>实验步骤</strong></p><h3 id="3-1-启动YARN"><a href="#3-1-启动YARN" class="headerlink" title="3.1   启动YARN"></a>3.1   启动YARN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/hadoop</span><br><span class="line"># sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401010046446.png" alt="image-20230401010046446"></p><h3 id="3-2-查看hadoop官方给了哪些例子"><a href="#3-2-查看hadoop官方给了哪些例子" class="headerlink" title="3.2   查看hadoop官方给了哪些例子"></a>3.2   查看hadoop官方给了哪些例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd bin</span><br><span class="line"># hadoop jar ../share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401010224365.png" alt="image-20230401010224365"></p><h3 id="3-3-以grep例子作为实验，查看grep例子的用法"><a href="#3-3-以grep例子作为实验，查看grep例子的用法" class="headerlink" title="3.3 以grep例子作为实验，查看grep例子的用法"></a>3.3 以grep例子作为实验，查看grep例子的用法</h3><p>grep例子的作用是给出一个正则表达式和一系列文件（也可以是单个文件），统计正则表达式匹配到的单词的次数。</p><p>想要知道具体某个例子怎么使用，可以在上面的命令后面跟上这个例子的名称加–help:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hadoop jar ../share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep --help</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401010250578.png" alt="image-20230401010250578"></p><p>可以看到，grep例子后面跟着的是输入文件目录和输出文件目录，然后是正则表达式。</p><h3 id="3-4-创建要处理的数据"><a href="#3-4-创建要处理的数据" class="headerlink" title="3.4 创建要处理的数据"></a>3.4 创建要处理的数据</h3><p>我们先在Hadoop安装目录&#x2F;usr&#x2F;local&#x2F;hadoop下创建一个文件，使用如下命令快速创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/hadoop</span><br><span class="line"># echo &quot;hello world.the world is hadoop world&quot; &gt; input.txt</span><br><span class="line"># cat input.txt </span><br><span class="line">hello world.the world is hadoop world</span><br><span class="line"> </span><br><span class="line"># bin/hdfs dfs -put input.txt /</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401010329336.png" alt="image-20230401010329336"></p><p>echo 命令会输出双引号中的字符串，而&gt;命令则将输出重定向到文件input.txt中。</p><h3 id="3-5-用hadoop命令提交作业，运行作业"><a href="#3-5-用hadoop命令提交作业，运行作业" class="headerlink" title="3.5   用hadoop命令提交作业，运行作业"></a>3.5   用hadoop命令提交作业，运行作业</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep /input.txt output world</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/misdazzling/photobed@main/img/image-20230401010344588.png" alt="image-20230401010344588"></p><h3 id="3-6-查看结果"><a href="#3-6-查看结果" class="headerlink" title="3.6   查看结果"></a>3.6   查看结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4.  # bin/hdfs dfs -cat output/p*</span><br><span class="line">5.  3    world</span><br></pre></td></tr></table></figure><p>可以看到，在结果文件中显示，匹配到正则表达式：world的次数为3次。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算实验1</title>
      <link href="/article/ecacc437.html"/>
      <url>/article/ecacc437.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-GitHub中建立仓库"><a href="#1-GitHub中建立仓库" class="headerlink" title="1.  GitHub中建立仓库"></a>1.  GitHub中建立仓库</h1><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image002.jpg" alt="img"></p><p>记得添加readme文件。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image004.jpg" alt="img"></p><h1 id="2-GitHub到本机"><a href="#2-GitHub到本机" class="headerlink" title="2.GitHub到本机"></a>2.GitHub到本机</h1><p>使用git指令同步github上的仓库</p><p><strong>克隆现有的仓库</strong></p><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。 如果你对其它的 VCS 系统（比如说 Subversion）很熟悉，请留心一下你所使用的命令是”clone”而不是”checkout”。 这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 <code>git clone</code> 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库 （虽然可能会丢失某些服务器端的钩子（hook）设置，但是所有版本的数据仍在，详见 <a href="https://git-scm.com/book/zh/v2/ch00/_getting_git_on_a_server">在服务器上搭建 Git</a> ）。</p><p>克隆仓库的命令是 <code>git clone &lt;url&gt;</code> 。 比如，要克隆 Git 的链接库 <code>libgit2</code>，可以用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/misDazzling/CloudComputingExperiment.git</span><br></pre></td></tr></table></figure><p>使用git clone 不仅可以克隆该git仓库服务器上几乎所有的数据，而且默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来，可以建立本地和远程仓库的联系。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image006.jpg" alt="img"></p><p>本地文件夹如图所示。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image008.jpg" alt="img"></p><h1 id="3-对分支进行操作"><a href="#3-对分支进行操作" class="headerlink" title="3.对分支进行操作"></a>3.对分支进行操作</h1><p>本地创建新的分支 test1，并使用指令查看。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image010.jpg" alt="img"></p><p>切换到test1分支。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image012.jpg" alt="img"></p><p>在本地仓库中新建了一个test1.txt文件，然后将其添加到本地仓库的test1分支中。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image014.jpg" alt="img"></p><p>我们ls查看test1分支下的所有文件，再切换到main分支中查看，发现没有test1.txt文件，这是由于没有合并分支。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image016.jpg" alt="img"></p><p>下面将test1和main分支进行合并，合并后用ls查看mainr分支下的文件，发现出现了test1.txt文件，说明合并成功。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image018.jpg" alt="img"></p><p>此时我们就可以删除tes1t分支了，删除后只剩下主分支main</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image020.jpg" alt="img"></p><h1 id="4-Fetch远程代码"><a href="#4-Fetch远程代码" class="headerlink" title="4.Fetch远程代码"></a>4.Fetch远程代码</h1><p>首先在github修改README.md文件，然后在云端提交。这里练习的是，上传远程仓库之前需要抓取远程仓库最近的修改，防止丢失远程仓库最新的提交和修改。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image022.jpg" alt="img"></p><p>然后fetch到本地</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image024.jpg" alt="img"></p><p>使用命令将更新同步到本地，使用cat查看README.md文件，发现已经是最新版本。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image026.jpg" alt="img"></p><p>然后git push 推送到远程仓库。</p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image028.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/clip_image030.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六更--查找目标与逻辑漏洞</title>
      <link href="/article/2a595fa5.html"/>
      <url>/article/2a595fa5.html</url>
      
        <content type="html"><![CDATA[<h1 id="查找目标"><a href="#查找目标" class="headerlink" title="查找目标"></a><strong>查找目标</strong></h1><h2 id="1-从已知文库寻找目标："><a href="#1-从已知文库寻找目标：" class="headerlink" title="1.从已知文库寻找目标："></a><strong>1.从已知文库寻找目标：</strong></h2><p>   目前常见文库： peiqi文库（不需要邀请码），零组文库和白泽文库（需要邀请码）<br>此次选择peiqi文库：<a href="http://wiki.peiqi.tech/">http://wiki.peiqi.tech/</a><br>   由于我之前是挖edusrc,所以我在打击目标的时候，都是找关于学校的web系统于是开始寻找目标：</p><ol><li>找web应用，然后查看关于学校应用的系统漏洞，并获取fofa关键词，自己再去进行漏洞挖掘（ 一般出现过的漏洞系统，肯定不止一个存在漏洞，每个人的思路不一样，所挖掘到的漏洞就不一样）<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/91b6125db6714139914da2852df78eac.png" alt="在这里插入图片描述"></li></ol><h2 id="2-对fofa关键词查看"><a href="#2-对fofa关键词查看" class="headerlink" title="2. 对fofa关键词查看"></a><strong>2. 对fofa关键词查看</strong></h2><p>自己通过已知漏洞去获取对自己有用的资源（比如任意漏洞下载我们就可以通过这个获取web系统的源码，下一步进行白盒审计，或者能前台getshell 的，我们就可以通过命令执行或者写马去获取资源<br>body&#x3D;”DC_Login&#x2F;QYSignUp”<br>   <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/cb7f366cfcbd4195884e0218f15a1ed6.png" alt="在这里插入图片描述"></p><h3 id="3-历史漏洞复现"><a href="#3-历史漏洞复现" class="headerlink" title="3. 历史漏洞复现"></a><strong>3. 历史漏洞复现</strong></h3><p>（找到能还原复现的站点，如果全部修复，就自己新挖掘该系统）<br>  由于漏洞详细可以知道，在前台企业注册点可以得知，存在文件上传点：<br><a href="http://x.xx.xxx.xxx:3306/DC_Login/QYSignUp">http://x.xx.xxx.xxx:3306/DC_Login/QYSignUp</a><br>然后开始文件上传获取webshell（通过插件（wappalyzer）得知是asp马子）：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/fd5331b8ea8b478294c7ccfe51fdf25e.png" alt="在这里插入图片描述"></p><p>此漏洞已被修复（后面的就用peiqi的图片表示）：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/af58a009898942a0a1eec1705b72cd5b.png" alt="在这里插入图片描述"></p><p>当你通过此漏洞获取到webshell时候，你就可以打包源码，进行代码审计，如果审计成功，通杀就获取了，轻松愉快 上分。<br>  当然，如果你不会代码审计，那就只有玩黑盒：<br>一.通过文库获取到脆弱系统，一般看见登录框常见两个操作：<br>1.弱口令 admin&#x2F;admin  admin&#x2F;123456  或者收集一个小字典（常见管理员账号和密码大约1w就行）<br>2.万能密码  根据语言来选择  比如asp: ‘or 1 &#x3D; 1 –   具体绕过的自己分析<br>这是常见的两种方法：（弱口令yyds）<br>案例：</p><blockquote><p><a href="http://xxx.xx.xxx.xxx:8001/DC_Login/Index">http://xxx.xx.xxx.xxx:8001/DC_Login/Index</a>   admin\admin</p><p><a href="http://xxx.xxx.xxx.xxx:8989/DC_Login/Index">http://xxx.xxx.xxx.xxx:8989/DC_Login/Index</a>   admin\admin</p></blockquote><p>当时测出大约有15个系统系统存在，然后提交edu吃了点烂rank。</p><ol start="3"><li>   当进入系统后台后重点关注的功能点：<strong>用户管理功能</strong>（这个功能点几乎所有后台都会有的，测试方法是添加管理员的时候删除cookie，如果成功，则可能通杀该系统所有站点）<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/dc86ed5e0d1a44c8a8091fec09c7576b.png" alt="在这里插入图片描述"></li></ol><p>漏洞复现：</p><blockquote><p><a href="http://xxx.xxx.xx.xx:8989/%E8%83%BD%E5%BC%B1%E5%8F%A3%E4%BB%A4%E8%BF%9B%E5%85%A5%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%9A">http://xxx.xxx.xx.xx:8989/能弱口令进入的系统：</a> admin\admin</p></blockquote><ol><li>   添加管理员处抓包，然后发送包添加成功：</li></ol><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/b5c7df126ae248fc95c68cfa86ba67e0.png" alt="在这里插入图片描述"></p><ol start="2"><li>   删除cookie后尝试能否添加成功，发现也可以添加成功：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/c146f068a5244ecf84b122b14c157d9a.png" alt="在这里插入图片描述"></li></ol><p>返回查看：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/7b1147b3408945029fc814382d8cecc9.png" alt="在这里插入图片描述"></p><p>退出使用删除cookie后添加的账户，看看能否正常登录：（成功登录）</p><p> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/bebe6941f00446da8120c1b118925567.png" alt="在这里插入图片描述"></p><p>发现删除cookie后都可以，这样将不可以登录的站点，看看使用此数据包，是否可以成功登录：<br>案例站点：<a href="http://xxx.xxx.xx.xx:8001/#">http://xxx.xxx.xx.xx:8001/#</a><br>将数据包中的host换为目标站点的ip</p><blockquote><p>POST &#x2F;DC_BASE_QXGL_User&#x2F;SaveData HTTP&#x2F;1.1 Host: xxx.xx.xx.xx:8989<br>Content-Length: 151 Accept: <em>&#x2F;</em> X-Requested-With: XMLHttpRequest<br>User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64)<br>AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;91.0.4472.124<br>Safari&#x2F;537.36 Content-Type: application&#x2F;x-www-form-urlencoded Origin:<br>Referer: &#x2F;DC_BASE_QXGL_User&#x2F;UserEdit?eid&#x3D;add Accept-Encoding: gzip,<br>deflate Accept-Language: zh-CN,zh;q&#x3D;0.9 Connection: close</p><p>eid&#x3D;add&amp;fmDataStr&#x3D;{“uid”:”-1”,”utype”:”0”,”ghxh”:”200”,”uname”:”test2”,”psw”:”admin123”,”psw2”:”admin123”,”roleid”:”2”,”rolename”:”ç®¡çå”}</p></blockquote><p>将目标站点的ip写在数据包中的host，然后burp修改目标，进行放包：<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/ef6340924d7b4e69b25fcc83113ae3f3.png" alt="在这里插入图片描述"></p><p>可以看见处理，在尝试登录：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/e9d09f9ea9fb45a2869c87966c74548e.png" alt="在这里插入图片描述"></p><p>Ok   通杀到手，补天通用给了100元，然后edu刷了30rank 。</p>]]></content>
      
      
      <categories>
          
          <category> edu挖掘思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edu挖掘思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五更--edusrc通用漏洞</title>
      <link href="/article/e3f27956.html"/>
      <url>/article/e3f27956.html</url>
      
        <content type="html"><![CDATA[<p><strong>edusrc通用思路：</strong><br>Ps:此文章是我在2021年四月份所写，这次就直接利用一下了！<br>思路：要想刷屏上分，就得找系统来挖掘，对于不会审计的我来说只有做一些黑盒测试（会审计大佬可以忽略这一点）<br>首先我们利用fofa找一些与edu有关的系统<br>语法：</p><blockquote><p>“系统” &amp;&amp; org&#x3D;“China Education and Research Network Center”</p></blockquote><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/cc38823654b84daf989a87d439b5f500.png" alt="在这里插入图片描述"></p><p>其中可以在前面加一些：阅卷系统、评分系统、直播系统、录播系统。（我们需要找的是弱口令能进去的系统）<br>此次渗透我使用的是：“点播系统” &amp;&amp; org&#x3D;“China Education and Research Network Center”<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/84e2bf1dbd764db38e19f3ff8780a29d.png" alt="在这里插入图片描述"></p><p>当确定系统后，我们就开始寻找目标站点，能通过弱口令进入的系统是最好的（admin\admin admin\123456)<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/9e1c1d352e034d029ce95d4ede6a9d42.png" alt="在这里插入图片描述"></p><p>通过上述的弱口令测试并没有进入后台，此时肯定会有爆破密码的想法，但是爆破成功的可能性太小了，于是我思考是否能通过找到操作手册发现默认密码，观察页面有关键字： 网瑞达和WRD视频直播点播系统<br>于是使用谷歌查找：WRD视频直播点播系统操作手册<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/de96dba89fca4c4ba6fc1b2e336ea8c6.png" alt="在这里插入图片描述"></p><p>点进去看看能否找到默认密码,运气还是好，碰巧发现了默认密码：默认管理端用户名『admin』 密码为<br>『Wrd123!@#』。<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/914c87de68fc434dbcb1577401097ddd.png" alt="在这里插入图片描述"></p><p>发现WRD视频直播点播系统默认密码后，继续使用fofa构造语句查找能进入的系统（如果大多数都是默认密码，此处就是一个弱口令通杀）<br>语法：“WRD视频直播点播系统” &amp;&amp; org&#x3D;“China Education and Research Network Center”<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/5ea51e59e8ef46e99b416e4022784c62.png" alt="在这里插入图片描述"></p><p>运气还是有点倒霉的，这么多站点只有一个通过默认密码进入了系统： <a href="http://223.99.203.174:8081/login">http://223.99.203.174:8081/login</a><br>（已修复），<br>测试完后，心里很复杂，这么多站点，就一个弱口令，看见有相关公司，于是在fofa一次公司名称，看看有没有别的站点：<br>语法：“网瑞达” &amp;&amp; org&#x3D;“China Education and Research Network Center”<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/b98a2025c2ad41af8d9657e79c28b98d.png" alt="在这里插入图片描述"></p><p>发现这个公司的系统产品挺多的然后继续进行默认密码测试，在1063个站点下，大约测试出了10多个站点， 全部已经提交平台并且修复：<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/c5af07ed0a794578b8d69d45d7d7e3d6.png" alt="在这里插入图片描述"></p><p>看着这么多站点 ，却只有一点点能通过默认密码进入，心里非常的失落，于是有了能不能越权登录的想法： 首先在登录框抓登录的返回包看见false,顺手修改为true,放包：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/84c0e4773888433690c9273045283633.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/5f35e2e72a2349e29b5f62b2ab6a2ee4.png" alt="在这里插入图片描述"></p><p>发现这样修改数据包，在放包时无任何反应，于是我思考，能不能用默认密码进入的站点的返回包放入不能登录的站点测试：<br>（通过测试，寻找到辅助站点：<a href="http://0.0.0.1/">http://211.64.117.58:9080/signin</a></p><p>获取到返回登录数据包：</p><blockquote><p>HTTP&#x2F;1.1 200 OK Server: Content-Type: application&#x2F;json Connection:<br>close Cache-Control: no-cache, private Date: Tue, 27 Apr 2021 03:00:35<br>GMT Set-Cookie:<br>laravel_session&#x3D;eyJpdiI6IllsZ3EzYTMxVnpKeGdtMnA0dmNXcnc9PSIsInZhbHVlIjoiREJQQ2VIbVNhXC9<br>VVE1hWEZ2NTdpa1lralZ6dXRxT0JnNkwzd3JrSEJqMHBlZ001YXhzNFp0MGpvdE9TN0h1TkNQQW94Y<br>WFiWlFxbFNBOVpEVUVaVVBnPT0iLCJtYWMiOiI2MTRkYjYyNjA0YzRlNTk3MjczYjYwMzEzMDZiN2M1<br>NDg5ZmY1MTAzODIxM2E3ZjM2NDc5Njc3ZWU4MTdmMDI5In0%3D; expires&#x3D;Tue,<br>27-Apr-2021 05:00:35 GMT; Max-Age&#x3D;7200; path&#x3D;&#x2F;; httponly<br>Content-Length: 291 {“success”:true,“data”:{“token”:<br>“eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjEsImlzcyI6Imh0dHA6Ly8yMTEuNjQuMTE3LjU4<br>OjkwODAvYXBpL3NpZ25pbiIsImlhdCI6MTYxOTQ5MjQzNSwiZXhwIjoxNjE5NTA2ODM1LCJuYmYiOjE2<br>MTk0OTI0MzUsImp0aSI6Ik5RUWtScEZOOUE4Y1d6bWEifQ.U2tsG3rqnt8Qe1lX9rHR1HmHBJlS5mOB<br>OmKkInF_GaM”}}</p></blockquote><p> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/65f63b9c441e4fbf8cd58a86b44b312d.png" alt="在这里插入图片描述"></p><p>去访问目标站点：<a href="http://0.0.0.1/">http://202.193.24.122:9080/signin</a>，然后在登录处输入账号admin 密码任意 ，抓返回， 将包换为刚获取的成功登录包然后放包：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/c0e4f2abbb20493d9975a4d40c05b8a1.png" alt="在这里插入图片描述"></p><p>点击放包，没想到全部的数据包放完后，就成功的进入到后台了<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/49d31468745441ef91fdd55391d52866.png" alt="在这里插入图片描述"></p><p>随后我任意选择了几个不同的学校进行了测试，都可以通过此方法进入后台，通过收集，一共有400所高校被日。</p>]]></content>
      
      
      <categories>
          
          <category> edu挖掘思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edu挖掘思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四更--对Js接口的继续探讨</title>
      <link href="/article/910ed97f.html"/>
      <url>/article/910ed97f.html</url>
      
        <content type="html"><![CDATA[<p><strong>第四更:</strong><br>Ps:此次是对一个系统的具体挖掘方法，在我们挖掘漏洞的时候，遇见困难的，在自己技术和知识积累的情况达不够的时候，就可以放弃换简单的系统挖掘，一般脆弱系统为弱口令能进去的系统，之后在对后台挖掘，edusrc平台的某位核心白帽子都是靠弱口令上去的！！！</p><h1 id="对Js接口的继续探讨"><a href="#对Js接口的继续探讨" class="headerlink" title="对Js接口的继续探讨"></a><strong>对Js接口的继续探讨</strong></h1><p>​                                                                       </p><p>目标站点：<a href="http://">http://202.197.xx.xxx/（学校常用的视频点播平台）</a><br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/7fd87fa6ba574738aa99b50768153988.png" alt="在这里插入图片描述"></p><p>开局也是这样的一个登录框，当然首先测试就是弱口令admin&#x2F;admin (admin&#x2F;123456) 等常规的密码， （可以进行小量字典爆破一下），但是都没有办法进入，于是尝试寻找操作手册或者初始密码看是否能进入后台。<br>谷歌寻找操作手册：<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/06a668cf5e3b4e68b3df5d9cf169ebf6.png" alt="在这里插入图片描述"></p><p>操作手册能寻找到很多,但是点进去观看一看翻后，只提示了管理员账号为admin&#x2F;初始密码需要自己设置，这种情况下，我们就不要继续在死磕查找弱口令，因为管理员一般在这种情况下是不可能继续设置简单的密码的。<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/13eb2dd60b0a40ee8774d3ee17f66439.png" alt="在这里插入图片描述"></p><p>操作手册没有任何帮助后，我又再次返回登录页面，这时候我们就可以查看js文件，或者网页源代码来帮助我们挖掘漏洞：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/3b1d237ec0d04998ab18595ffd1ebb19.png" alt="在这里插入图片描述"></p><p>在翻阅后看到这个接口：<br>（get方法构造请求，post传输参数）能看懂ajax吧，看不懂的就需要去弥补js的知识，随手构造接口访问试试：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/9f9c2cdfba3d434ab50814b681528f77.png" alt="在这里插入图片描述"></p><p>没想到报错爆出另一个参数，然后构造语法开始对管理员密码重置：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/d06f3efdfd914c34aaa7131b16c8ed19.png" alt="在这里插入图片描述"></p><p>success出现，更改管理员密码的逻辑漏洞到手，但是我的习惯一般都是先改弱口令然后在提交逻辑漏洞：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/01e8c116647141d09f7d07885902c9df.png" alt="在这里插入图片描述"></p><p>成功重置密码进入后台，后台可以上传文件到达getshell，由于上传没有难度，无waf，我就不记录了，</p><p>站点大约有38个全是edu的：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/52ffe5e01cc049428bd7c82deaaf21bd.png" alt="在这里插入图片描述"></p><p>js接口需要熟练的使用，那么逻辑的0day唾手可得，下面这个系统也是同样的方法：我就直接上报告分析了：此系统大约50 个站点全部以修复<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/e35bc64e607b475597aeafbc59ebaad0.png" alt="在这里插入图片描述"></p><p>总结：其实挖洞还是细心和个人思维，黑盒测试玩的就是思路，想法有多大，漏洞就有多大，别以为不可能，或者一直和waf死磕。</p>]]></content>
      
      
      <categories>
          
          <category> edu挖掘思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edu挖掘思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三更--接口漏洞实战</title>
      <link href="/article/ac9f297d.html"/>
      <url>/article/ac9f297d.html</url>
      
        <content type="html"><![CDATA[<h1 id="接口漏洞实战"><a href="#接口漏洞实战" class="headerlink" title="接口漏洞实战"></a>接口漏洞实战</h1><p>前言： 在我们信息收集获取webvpn或者sslvpn后，我们就可以进入一站式服务大厅进行漏洞挖掘。</p><h2 id="一、漏洞介绍："><a href="#一、漏洞介绍：" class="headerlink" title="一、漏洞介绍："></a>一、漏洞介绍：</h2><p>   1.水平越权访问是一种“基于数据的访问控制”设计缺陷引起的漏洞。由于服务器端在接收到请求数据进行操作时没有判断数据的所属人&#x2F;所属部门而导致的越权数据访问漏洞，<strong>而这种越权最容易出现的位置就是？Id&#x3D;（传参值） 和post传参的参数中，或者存在个人信息页面，个人资料这些隐藏的接口中</strong></p><h2 id="2-方法一："><a href="#2-方法一：" class="headerlink" title="2.方法一："></a>2.方法一：</h2><p>​     往往在挖掘过程程中，拿到同一个站点，别人能挖掘出水平越权或者垂直越权，而你却不能发现，那些因为这些越权漏洞的传参值都是接口在进行，所以我们在挖掘的过程中可以打开burp抓住每一个包，然后再去看burp中的http历史记录，查看接口信息，在进行测试<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/8afba1a773ed4ca69b08c02ec70dc579.png" alt="在这里插入图片描述"></p><p>如上图一样，如果在站点页面是无法看见?sid这个参数的，而你在burp历史包中即可以看见此参数，这个参数就是个人身份的参数，如果没鉴权，那么水平越权就到手。<br>  方法二：<br>    直接使用浏览器的控制台中的网络即可查找，比如：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/58f17668983d4a19989b171319c0b16d.png" alt="在这里插入图片描述"></p><p>可以看出这个页面，你根本没有任何办法测试水平越权，但是你可以通过查看接口的办法将个人信息的接口查找出来后进行测试：<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/fa698d70625a451ca0bfe33348c6e872.png" alt="在这里插入图片描述"></p><p>调用后，你可以将参数？abllid&#x3D;参数值换为别人的参数，即可测试存在越权不：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/755d80ecc9bf4f7f9b46ee35f33c73e6.png" alt="在这里插入图片描述"></p><h1 id="二、案例（某证书大学的挖掘）："><a href="#二、案例（某证书大学的挖掘）：" class="headerlink" title="二、案例（某证书大学的挖掘）："></a>二、案例（某证书大学的挖掘）：</h1><p><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/0fbb59421d874d31ad660fbc3d0fc981.png" alt="在这里插入图片描述"></p><p>（这次是打的组合拳，我都没有想到在B站点的接口中泄露全校师生的values，所以在挖一个学校的时候，不要着急提交漏洞，应该慢慢的全部系统的都分析一下，遇见有用的就记录下来）<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/45d3ce00e62746aeb845dbd156050021.png" alt="在这里插入图片描述"></p><p>第二处漏洞：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/8306fffcfe0a4e018adb9547b3633cc6.png" alt="在这里插入图片描述"></p><p>可以清楚的看见，sfz是进行了加密处理的，但是你在f12查看个人接口的时候，你会发现接口中的数据全是清晰可见<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/85acb92d5a5f4f08a7f2c862bd15d27d.png" alt="在这里插入图片描述"></p><p>  所以挖越权漏洞要多调用burp的历史记录或者f12查看接口，往往对接口的鉴权是程序员经常忽略的。<br>三、方法三使用脚本jsfind进行查找：<br>站点：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/d035565a2bfb4354952d20204b69251f.png" alt="在这里插入图片描述"></p><p>使用脚本：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/d30192b6e7b54e349bc292df77811b54.png" alt="在这里插入图片描述"></p><p>可以看出很多接口，访问即可，有前台未授权上传和前台ssrf 就不上图了</p>]]></content>
      
      
      <categories>
          
          <category> edu挖掘思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edu挖掘思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二更--信息收集</title>
      <link href="/article/903d3d04.html"/>
      <url>/article/903d3d04.html</url>
      
        <content type="html"><![CDATA[<p>​                   </p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>  对于我们在挖edusrc的时候遇见最大的问题就是如何突破一站式服务大厅的网站，要突破这一点，我们就需要拥有教师的gh 、sfz和 学生的sfz、 xh这些个人隐私信息，所以我们就需要做好信息收集：<br>1.## 利用好谷歌语法查找敏感信息：</p><p>   site:xxx.edu.cn<br>    这个语句是寻找这个学校的相关域名的站点，但是在这个后面加一些敏感信息就可以指定查找了，比如：</p><blockquote><p>site:xxx.edu.cn  sfz      site:xxx.edu.cn  xh</p></blockquote><p>这样的等条件<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/ed1c54515b3245b08b1b0f592c7babaa.png" alt="在这里插入图片描述"></p><p>如上图一样，直接可以从这个pdf中获取很多信息，一般隐私信息都会以doc pdf xls 这些文件发布到网上，所以造成信息泄露（如果你不追求什么漏洞，上上rank 这一个都够你上几百rank  就谷歌收：site:.edu.cn  sfz   filetype: pdf|xls|doc 即可。<br>  如果以上没有找到自己想要的信息，你就可以去找所在学校相关的教育局站点，因为助学金等奖励都会通过当地教育局进行展开，这样在相关教育局站点我们也可以收集到我们需要的信息。<br>2.## 利用谷歌语法查找脆弱的系统获取信息：</p><pre><code>site:xxx.edu.cn  初始密码</code></pre><p>   利用上面的语法可以查找许多相关弱口令系统，然后利用上面收集的信息，进行登录，从这些能登录进去的系统，我们也可以获取很多有用的信息，在进一步说，至少我们有学生权限的账号了，可以测试水平或者垂直漏洞，毕竟后台漏洞是要比前台多：<br>    <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/e130bc7dedf24a2f9dbdd86726db8c88.png" alt="在这里插入图片描述"></p><p>然后利用我们收集的信息大量尝试登录即可<br>（这是写文章随手挖的）：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/6da0c5ac37f542369feba3e838288aba.png" alt="在这里插入图片描述"></p><p>然后再利用我们的初始密码解说去大量爆破弱口令用户：<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/fd7c498d07db4a4bb2da30ee1c906010.png" alt="在这里插入图片描述"></p><p>此次是很顺利的获取的sfz 和xh 这些信息所以这个系统轻松登录，如果二者缺一可以思考如何获取，这一点自己思考：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/bba679ea60bf4aeab94c6c73a894c38f.png" alt="在这里插入图片描述"></p><p>后面继续正常漏洞即可，不管出货不出货都可以获取自己想要的信息，上面即可看出大量的信息泄露。<br>3. ## 案例：</p><p>   去年是某天的专属src 获取奖励1k：</p><p> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/8f06a682b3d24ce2bfd7922278735a93.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/3dff73ba77f44e388d048db36156b666.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/82db69968d364b97a813a507f490e220.png" alt="在这里插入图片描述"></p><p> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/74e0d55bc19543ac905a332a84192258.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> edu挖掘思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edu挖掘思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一更--教育src如何日刷百分</title>
      <link href="/article/4873931e.html"/>
      <url>/article/4873931e.html</url>
      
        <content type="html"><![CDATA[<h1 id="教育SRC日刷百分"><a href="#教育SRC日刷百分" class="headerlink" title="教育SRC日刷百分"></a>教育SRC日刷百分</h1><p>Ps:<br>（对于edu想上分的同学有两种方式：1.挖通用2.定点打击学校，全部日穿。此文采用的是第二种方法）<br>首先确定目标学校：对于学校可以在平台上选择漏洞较少的学校，因为学校可能没有被多少人挖过，很少被通报，猜测学校的安全意识比较低，所以这次我就去给这样的学校好好的上一课。这是本次的成果，edu上分80多rank，用时一天，edu高校如此多，每天打一个，那么上分不是轻轻松松了？<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/fed1d2ed48424710b6131380810698b3.png" alt="在这里插入图片描述"></p><p>目标：<a href="https://www.xxxxxx.edu.cn/">https://www.xxxxxx.edu.cn/</a><br> <img src="https://img-blog.csdnimg.cn/1acf7f9f89e74f78826ece46edeb2d8d.png" alt="在这里插入图片描述"></p><p>确定目标之后就是对于该学校的信息收集，主要收集：xh、SFZ、gh、电话号码等信息，因为信息收集是渗透的核心，如果信息收集几分钟，那么你挖洞就是几个星期或者几个月都不会出货，如果信息收集够多，那么挖洞就会很快出货。</p><h2 id="1-信息收集："><a href="#1-信息收集：" class="headerlink" title="1.信息收集："></a><strong>1.信息收集</strong>：</h2><p>对于高校，一般可以利用谷歌语法：filetype:xls  site:xxx.edu  sh  gh  SFZ 这些去收集我们所需要的东西，也可以去当地的教育局官网查看有没有敏感信息泄露，比如贫困生补助，奖学金补助等等文件很容易泄露重要信息的，再者就是在学校官网查看看有没有信息泄露，一般有公示文件，这些文件也特别容易泄露信息，最后最后就是sg了，当然这个我可不介意哈哈哈哈哈（虽然wo特别喜欢，毕竟一个证书大学一个女朋友嘿嘿嘿）<br>此次突破就是该学校的官网泄露，造成此次的渗透事件，所以高校在发文时一定要做好脱敏处理<br><a href="https://www.xxxx.edu.cn/xxxx/info/1017/1222.htm">https://www.xxxx.edu.cn/xxxx/info/1017/1222.htm</a>(可以看出是主站泄露了同学的sfz，然后我们再利用该信息，反查xh，这样就可以利用sfz和学号的弱口令进入webvpn，然后开始挖掘漏洞）<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/902297028ff44e2ca6bcf7409e4ef75e.png" alt="在这里插入图片描述"></p><h2 id="2"><a href="#2" class="headerlink" title="2."></a><strong>2.</strong></h2><p>信息收集搞好后，就可以开始渗透之旅了，利用收集好的账号和sfz对官网一站式服务大厅进行爆破（高校网络安全意识差，肯定存在弱口令的），找到门户服务网站此时一定要注意门户网站的帮助说明这些，因为这里会告诉你默认密码的情况：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/daa983dc56fc4c08b8caae4b32974bda.png" alt="在这里插入图片描述"></p><p>当我们点开帮助说明的时候，几乎就可以露出笑容了：很清楚的写出来了初始密码：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/7cb2905638614e639779032945f08b0a.png" alt="在这里插入图片描述"></p><p>我们信息收集的也很顺利，其中很多账号都是默认口令，于是开始对系统一一进行测试：<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/b3bf7f86d73c43bf989d24f0b39ead2c.png" alt="在这里插入图片描述"></p><p>然后开始对每一个系统都开始进行测试，当然，进去后我最喜欢的系统一般是人事系统，学生管理系统等等，这个懂的都懂：<br>所以我第一个打的就是人事系统了，可以继续猜测，这个学校没有任何安全意识，于是这个人事系统也可以猜测大多数为弱口令，加上刚才收集的老师和学生账号开始测试：直接抓包爆破，果然在我猜测之中，该系统全体师生都是弱口令：66xx66<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/2d31e0c4f3484ba8a5f09c9b302dd354.png" alt="在这里插入图片描述"></p><p>当进入这个系统后，就可以宣判这个学校结束了<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/53f52fd5f5904a23a64148f3b267a1bc.png" alt="在这里插入图片描述"></p><p>（当然这时候才是开始）全校师生的个人的信息全部泄露：<br>此系统因为弱口令泄露了很多信息，其余逻辑都测试和一些不重要的xss我就不写了，然后进行学工系统的测试（当然这个系统也是全校学校师生弱口令）</p><blockquote><p>url为 <a href="http://xx.xxx.xxx.xxx:8312/admin/login/index">http://xx.xxx.xxx.xxx:8312/admin/login/index</a></p></blockquote><p>弱密码登录，密码是账号<br>我使用的测试账号为202121 输入密码202121  然后第一次登录系统会自动进行密码重置，重置密码为Test123#<br>此处提供一个未重置密码的测试账号20212121 密码2007002(此处全是虚假信息）<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/ba882ae290fc458ea663ded6f76792e4.png" alt="在这里插入图片描述"></p><p>我们使用学生账号登录成功后，对于该系统进行测试，没有上传点，sql注入的waf也挺严的，于是我只有考虑逻辑漏洞，没想到，这个系统对于权限控制的很无语，可以水平和垂直越权：（此处直接修改id即可越权，然后此系统中每个功能点都能如此越权，也可以直接越权到管理员权限，此处不一一上图了）</p><p> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/ac231ccd9412447a840f8164bd620ca9.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/9d3ca9ec5e2d420085e2e7c1c62bfd77.png" alt="在这里插入图片描述"></p><p>此系统还有一个有趣的地方就是任意密码重置，可以直接将管理员密码重置：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/f73e971fceec41ae8ab95105b3800923.png" alt="在这里插入图片描述"></p><p>进行抓包，然后修改数据包即可：<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/cb85e324019a456794fc382984d9df06.png" alt="在这里插入图片描述"></p><p>然后退出尝试登录，一发不可收拾：获取管理员权限后，然后又是再一次泄露全校师生个人信息，此系统共15个越权点和数不清的存储xss（这个就不截图了）<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/436607075ca146269c2a789a8b8f62bf.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/3526973d8b224f579973eab1cb32f685.png" alt="在这里插入图片描述"></p><p>拿下系统管理员权限后，进去可以获取管理员的路径url，然后使用学生权限的账号也可以直接越权访问，由于毕竟无聊，我就不截图了，其实还是我比较懒。。。<br>然后继续测试考试系统，此系统也是无数个漏洞，此文章我就写一个我个人感觉有点意思的漏洞，越权添加管理员：<br>url为<a href="http://10-20-100-236.webvpn1.xxxxx.edu.cn:8125/">http://10-20-100-236.webvpn1.xxxxx.edu.cn:8125</a><br>使用之前获取的学生账号登录后，来到用户管理，添加用户，填写用户信息。账号001 密码123456 点击保存<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/040b97072c284b2a879d486ea84009ae.png" alt="在这里插入图片描述"></p><p>抓包，将ddlRole参数值改为0，然后放包<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/5a7812c3c9074b639864d9f11f7f5677.png" alt="在这里插入图片描述"></p><p>退出登录，然后登录刚刚创建的管理员账户001 密码123456<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/2c4d84a0e31d4239b053fe39d3d2285b.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/7958cc652a0944c2b64d85e44051feb3.png" alt="在这里插入图片描述"></p><p>成功添加，此处还有一个修改返回包可以到达任意用户登录的漏洞我就不简单叙述了，到此还有很系统都存在如此的逻辑漏洞，我就不继续浪费大家的时间了，如果对一个学校就这样测试肯定就显得很没有意思了，在我测试逻辑测试到无聊的时候，我又返回到了学工系统，因为这个系统我用管理员账号登录的时候发现了文件上传点（不想拿shell 的渗透测试人员都不是好的人员）</p><h3 id="1-学工系统文明寝室评选管理文件上传存在cgi解析漏洞"><a href="#1-学工系统文明寝室评选管理文件上传存在cgi解析漏洞" class="headerlink" title="1.学工系统文明寝室评选管理文件上传存在cgi解析漏洞"></a>1.学工系统文明寝室评选管理文件上传存在cgi解析漏洞</h3><p> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/d8ce613ad68c4ebeb0f2823d09ba1672.png" alt="在这里插入图片描述"></p><p>直接上传图片马然后访问加上&#x2F;.php即可，此漏洞简单我就不讲述原理了：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/9724c11a15e547d1b920d51bb5e2b9ff.png" alt="在这里插入图片描述"></p><p>当然这个解析漏洞只能命令执行不能上webshell，然后我在继续测试的过程中发现可以直接上传php马子，这就让我无语了，我抓包修改后缀没有上传成功，但是我直接上传php的哥室拉马子反而成功，这是我到现在都很迷的：（其余马子都不能上传，一句话木马可以命令执行但是链接不了webshell管理器）<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/f7bc42b0d69c4a3ea27d266fd63aa2e7.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/5f5a53f0f51347bebf7c9a6837323000.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/f858e892e617424ca82d752771eca7bf.png" alt="在这里插入图片描述"></p><p>当拿下shell后，确定了不是在云服务器上，我就心想，上线cs看看内网如何</p><p>于是接下来的就是常规操作，上线cs和搭建隧道进行内网渗透，内网也是漏洞百出，下文就不再写了，在edusrc中也是违规操作了，所以如果想上分的小伙伴可以像我这样定点打击目标系统，进入门户网站后，对每一个系统都认真的测试，因为逻辑漏洞太多太多了，本文也算是对逻辑漏洞的一种叙述，最后此次渗透就到此结束。</p>]]></content>
      
      
      <categories>
          
          <category> edu挖掘思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edu挖掘思路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进入vpn后网段查找方法</title>
      <link href="/article/ba6f225a.html"/>
      <url>/article/ba6f225a.html</url>
      
        <content type="html"><![CDATA[<h1 id="vpn漏洞挖掘方法"><a href="#vpn漏洞挖掘方法" class="headerlink" title="vpn漏洞挖掘方法"></a>vpn漏洞挖掘方法</h1><ol><li>   当你获取到sslvpn的时候，你可以进入内网，对其网段进行扫描挖掘漏洞，在内网中的漏洞是非常多的，比如数据库弱口令、ssh弱口令、设备弱口令、nday等等漏洞，当然这些都可以使用<strong>fscan</strong>进行即可</li></ol><p>网段的获取：<br>   登录一站式服务大厅：<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/2cc4211de1c941839a8c88245f9775f1.png" alt="在这里插入图片描述"></p><p>来到这里将能打开的应用都打开，然后获取url进行ping<br> <img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/716d00ed29f745b6ae288227466cb1dc.png" alt="在这里插入图片描述"></p><p>可以获取到一个ip，此时可以猜想这个网段肯定不止这一个服务然后进行二分法对b段ping存活即可<br><img src="https://raw.githubusercontent.com/misdazzling/photobed/main/img/b45d51f72d474d118119de52ddef6388.png" alt="在这里插入图片描述"></p><p>同理如上图可以看出存在192这个网段，那么就可以继续对这个网段利用python来探测b段或者使用Namp等工具。</p>]]></content>
      
      
      <categories>
          
          <category> edu挖掘思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edu挖掘思路 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
